Here’s a concrete, indexed SSOT layout you can drop into `DOC_STATE_MACHINES_SSOT.md` that **merges what’s in 3 (DOC_STATE_MACHINE.md) and 4 (Task/Workstream/Worker Lifecycle)**.

I’ll give you:

* YAML frontmatter
* A machine-readable index block
* A numbered section layout with clear “what goes here / which source” hints

You can then paste content from 3 & 4 into the right slots.

---

````markdown
---
doc_id: DOC-SSOT-STATE-MACHINES-001
status: draft
doc_type: ssot_guide
title: "State Machines – Run, Workstream, Task, Worker"
version: 0.1.0

source_docs:
  - DOC_STATE_MACHINE.md          # old canonical run/workstream spec (file 3)
  - STATE_MACHINES_TASK_WS_WRK.md # lifecycle spec (file 4, task/workstream/worker/events)

module_refs:
  - core/state
  - core/engine
  - core/orchestrator

owner: "STATE-MACHINES-MAINTAINER"
last_reviewed: 2025-12-08
---

# DOC_STATE_MACHINES_SSOT

## 0. Machine Index

```json
{
  "sections": {
    "1": "Purpose_and_Scope",
    "2": "Core_Concepts_and_Entities",
    "3": "Canonical_State_Machines",
    "4": "State_Transitions_and_Invariants",
    "5": "Persistence_Model",
    "6": "Event_and_Audit_Model",
    "7": "Derived_Behaviors_and_Aggregations",
    "8": "Operational_Procedures_and_Recovery",
    "9": "Versioning_and_Change_Log",
    "10": "Source_Mapping_and_Traceability"
  },
  "state_machines": {
    "run": "3.1",
    "workstream": "3.2",
    "task": "3.3",
    "worker": "3.4"
  }
}
````

---

## 1. Purpose and Scope

1.1 **Goal**

* Define this file as the **single source of truth** for:

  * Run lifecycle
  * Workstream lifecycle
  * Task lifecycle
  * Worker lifecycle
* All code, DB schemas, and event formats must conform to this spec.

1.2 **Out of Scope**

* UET-specific state machines (worker / patch ledger / test gates) – these live in their own SSOT.
* External tools’ internal state (Aider, Invoke, etc.).

---

## 2. Core Concepts and Entities

2.1 **Run**

* Short definition of a “run”.
* How a run relates to workstreams/tasks.

2.2 **Workstream**

* Definition and relationship to run and tasks.
* References to dependency graph (depends_on, critical vs non-critical tasks).

2.3 **Task**

* Definition of a task in this system.
* How it relates to workstreams and workers.

2.4 **Worker**

* Definition of worker (logical worker vs physical process).
* Responsibilities (execute tasks, send heartbeats, report status).

2.5 **Global Constraints**

* Time semantics (created_at, started_at, completed_at).
* Identity rules (IDs, foreign-key relationships).

> **Fill from:** introductory definitions + conceptual bits in both original docs.

---

## 3. Canonical State Machines

> **Rule:** Every state machine here gets:
>
> * Enumerated state set
> * Mermaid diagram (optional but preferred)
> * Natural language description

### 3.1 Run State Machine

3.1.1 **State Set**

* `pending`
* `running`
* `succeeded`
* `failed`
* `canceled`

3.1.2 **Diagram (Optional)**

```mermaid
stateDiagram-v2
    [*] --> pending
    pending --> running
    running --> succeeded
    running --> failed
    running --> canceled
    succeeded --> [*]
    failed --> [*]
    canceled --> [*]
```

3.1.3 **Semantics**

* Short meaning of each state (lift from DOC_STATE_MACHINE.md).

---

### 3.2 Workstream State Machine

3.2.1 **State Set**

* `pending`
* `ready`
* `blocked`
* `running`
* `succeeded`
* `failed`
* `skipped`

3.2.2 **Diagram (Optional)**

> Bring over / adapt mermaid or ASCII from the lifecycle doc.

3.2.3 **Semantics**

* Define each state, especially:

  * `blocked` = dependencies not met
  * `skipped` = terminal state, why it happens
* Note: must be consistent with the DB-layer rules from DOC_STATE_MACHINE.md.

---

### 3.3 Task State Machine

3.3.1 **State Set**

* `pending`
* `queued`
* `running`
* `validating`
* `completed`
* `failed`
* `retrying`
* `cancelled`

3.3.2 **Diagram (Optional)**

> Lift from the Task Lifecycle doc.

3.3.3 **Semantics**

* What triggers each state.
* How retries are triggered and limited.

---

### 3.4 Worker State Machine

3.4.1 **State Set**

* `initializing`
* `idle`
* `busy`
* `unresponsive`
* `shutdown`

3.4.2 **Diagram (Optional)**

> Lift from the Worker Lifecycle section.

3.4.3 **Semantics**

* Meaning of each state (idle vs busy vs unresponsive).
* How heartbeats drive transitions.

---

## 4. State Transitions and Invariants

> **This is where you merge the “valid transitions + validation rules” from DOC_STATE_MACHINE.md with the detailed guards/invariants from the lifecycle doc.**

### 4.1 Global Rules

* All transitions must be validated by a centralized function (e.g., `validate_state_transition(entity_type, from, to)`).
* Time ordering invariants (e.g., `started_at >= created_at`, `completed_at >= started_at`).

### 4.2 Run Invariants

* List valid transitions as a table:

  * `pending -> running`
  * `running -> succeeded|failed|canceled`
* Invalid transitions MUST be rejected and logged.

### 4.3 Workstream Invariants

* Dependency rules (`blocked` vs `ready`).
* “Terminal” states (`succeeded`, `failed`, `skipped`) – no further transitions.

### 4.4 Task Invariants

* `retrying` count limit.
* Requirements for moving to `validating` and `completed`.

### 4.5 Worker Invariants

* Heartbeat timeout → `unresponsive`.
* Cleanup requirements before `shutdown`.

---

## 5. Persistence Model

> **Bring over the DB-layer constraints from DOC_STATE_MACHINE.md and align them with the states above.**

### 5.1 Run Table

* Required columns: `id`, `state`, timestamps, etc.
* CHECK constraints on valid `state` values.

### 5.2 Workstream Table

* Columns (including `run_id`).
* Indexes relevant to state queries.

### 5.3 Task Table

* Columns for retry counts, last_error, etc.

### 5.4 Worker Table

* Columns for `last_heartbeat_at`, `capacity`, etc.

### 5.5 Foreign Key & Consistency Rules

* `workstream.run_id` → `run.id`
* `task.workstream_id` → `workstream.id`
* What happens to children when a parent transitions to terminal state.

---

## 6. Event and Audit Model

> **This section is almost entirely from the lifecycle doc’s JSONL event schema.**

6.1 **Event Format**

* Canonical event JSON schema (e.g. `entity_type`, `entity_id`, `from_state`, `to_state`, `timestamp`, `reason`, etc.).

6.2 **Event Streams**

* Where events are written:

  * `.state/transitions.jsonl`
  * DB audit tables (if any).

6.3 **Usage**

* How tools/processes should consume these events (dashboards, debugging, replay).

---

## 7. Derived Behaviors and Aggregations

7.1 **Workstream State from Task States**

* Rules such as:

  * All tasks `completed` → workstream `succeeded`.
  * Any critical task `failed` → workstream `failed`.

7.2 **Run State from Workstream States**

* Aggregation rules from DOC_STATE_MACHINE.md + lifecycle doc.

7.3 **Worker Load & Assignment**

* How worker state influences scheduling and task assignment.

---

## 8. Operational Procedures and Recovery

> **Pull from the “recovery” sections in the older workstream/step/circuit-breaker doc and align with this SSOT.**

8.1 **Identifying Stuck Entities**

* How to detect runs/workstreams/tasks stuck in a non-terminal state beyond thresholds.

8.2 **Manual Recovery Actions**

* Allowed manual transitions (e.g. `failed -> cancelled` allowed/not allowed?).
* Requirements for logging and event emission.

8.3 **Circuit Breakers (If Applicable Here)**

* Either:

  * Include a small sub-state-machine for circuit breakers, or
  * Link out to a separate DOC_CIRCUIT_BREAKERS_SSOT.

---

## 9. Versioning and Change Log

9.1 **Change Process**

* Who can change the state machine definitions.
* How changes are rolled out (code updates, DB migrations, docs updates).

9.2 **Change Log**

* `v0.1.0` – Initial merge of DOC_STATE_MACHINE.md and Task/Workstream/Worker Lifecycle doc.
* Future entries go here.

---

## 10. Source Mapping and Traceability

10.1 **Original Sources**

* Table listing:

  * `DOC_STATE_MACHINE.md` → sections that fed into 3.1, 3.2, 5.x.
  * `STATE_MACHINES_TASK_WS_WRK.md` → sections that fed into 3.3, 3.4, 6.x, 7.x.

10.2 **Implementation References**

* Pointers to:

  * DB schema files
  * Orchestrator modules
  * Any Pydantic/Typed models representing these state machines.

10.3 **Validation Hooks**

* Describe how automated checks will validate:

  * allowed state values
  * allowed transitions
  * event format conformity.

```



---

## ✅ Files You **CAN Delete** (After SSOT Is Finalized)

These are **true duplicates / superseded operator guides** whose content is fully representable inside the new SSOT:

### 1. Legacy Workstream/Step/Circuit Breaker Guide

You have **two copies** of the same document:

* `STATE_MACHINES.md`
* `STATE_MACHINES (2).md`

Both define:

* Workstream state machine
* Step state machine
* Circuit breaker state machine
* Recovery procedures
* `InvalidTransitionError`
* `state_transitions` audit table

These are structurally identical to the canonical operator guide with:

* `doc_id: DOC-GUIDE-STATE-MACHINES-397`
* and the duplicate without frontmatter

✅ **Action:**
Once your SSOT has:

* Workstream lifecycle
* Task lifecycle
* Worker lifecycle
* Recovery & auditing section (copied into §8 of SSOT)

You may safely delete:

* `STATE_MACHINES.md`
* `STATE_MACHINES (2).md`

---

### 2. Pure Run/Workstream Minimal Spec (Fully Subsumed)

`DOC_STATE_MACHINE.md` defines:

* Run states
* Workstream states
* DB enforcement logic
* `validate_state_transition()` enforcement policy

This content is **fully migrated into your new SSOT structure**:

* §3.1 Run State Machine
* §3.2 Workstream State Machine
* §5 Persistence Model
* §4 Transition Enforcement

✅ **Action:**
After the SSOT is populated with:

* Run transitions
* Workstream transitions
* DB constraints reference

You may **delete**:

* `DOC_STATE_MACHINE.md`

---

### 3. Task / Workstream / Worker Lifecycle Guide (Duplicate of SSOT Target)

`STATE_MACHINE (2).md` (the lifecycle guide with mermaid diagrams) defines:

* Task lifecycle
* Workstream lifecycle
* Worker lifecycle
* Event schema
* Derived state logic

This is the **primary source you are merging into the SSOT**.
Once merged, it becomes **redundant by definition**.

✅ **Action:**
After copy-merge into:

* §3.3 Task
* §3.4 Worker
* §6 Event Model
* §7 Derived Behaviors

You may **delete**:

* `STATE_MACHINE (2).md`

---

## ❌ Files You **MUST NOT Delete**

These are **architecturally separate SSOTs** and are **NOT merged into the orchestration SSOT**:

### UET V2 Internal State Machines

`STATE_MACHINES (3).md`
`STATE_MACHINES (4).md`

These define:

* UET V2 Worker (SPAWNING → TERMINATED)
* Patch Ledger
* Test Gate State Machine
* Ledger DB constraints
* Optimistic locking
* Gate blocking cascades

These belong to:

* **UET subsystem**
* **Patch validation pipeline**
* **Test gate enforcement**
* **NOT orchestration**

❌ **Do NOT delete these.**
They remain a **separate SSOT for UET V2**.

---

## ✅ Final Safe Deletion Checklist

You may delete **only after** these conditions are true:

1. `DOC_STATE_MACHINES_SSOT.md` is:

   * Created
   * Populated
   * Marked `status: active`
2. It contains:

   * Run state machine
   * Workstream lifecycle
   * Task lifecycle
   * Worker lifecycle
   * Transition invariants
   * Event/audit schema
   * Recovery procedures
3. No live code references the legacy filenames directly.

### ✅ Then You May Delete:

| File                  | Safe to Delete? | Reason                     |
| --------------------- | --------------- | -------------------------- |
| STATE_MACHINES.md     | ✅               | Duplicate operator guide   |
| STATE_MACHINES (2).md | ✅               | Duplicate                  |
| DOC_STATE_MACHINE.md  | ✅               | Superseded by SSOT         |
| STATE_MACHINE (2).md  | ✅               | Lifecycle merged into SSOT |

### ❌ Keep These:

| File                  | Keep?  | Reason          |
| --------------------- | ------ | --------------- |
| STATE_MACHINES (3).md | ❌ Keep | UET V2 internal |
| STATE_MACHINES (4).md | ❌ Keep | UET V2 internal |

---

## ⚠️ Strong Safety Recommendation (Since You’re Pruning Hard)

Before deleting anything:

```text
/backups/state_machines_pre_ssot_snapshot/
    STATE_MACHINES.md
    STATE_MACHINES (2).md
    DOC_STATE_MACHINE.md
    STATE_MACHINE (2).md
```

Archive once → then delete originals.

---

## ✅ Bottom Line

**Yes — you can safely delete the legacy state-machine files *except* the UET V2 ones, *after* the SSOT merge is finalized.**

If you want, I can:

* Produce a **diff-based merge checklist** (file → SSOT section mapping), or
* Build a **PowerShell safe-delete script** that only deletes after SSOT validation passes.


---

# ✅ Final Answer

> **YES — you can merge *all* state-machine files into one SSOT and delete the rest — IF you use a tiered namespace structure and preserve subsystem boundaries inside the SSOT.**

---

# ⚠️ Why This Is Normally Dangerous (And Why It’s Safe Here)

Normally this would be unsafe because you currently have **two different classes of state machines**:

1. **Orchestration Layer**

   * Run
   * Workstream
   * Task
   * Worker (runtime workers)
   * Recovery & audit

2. **UET V2 Internal Engine**

   * Patch ledger
   * UET workers
   * Test gates
   * Optimistic locking
   * Quarantine logic

These traditionally live in **separate SSOTs**.

However, in your system:

* They **interact**
* They share:

  * DB enforcement logic
  * Gate dependencies
  * Patch → test → commit chain
* You want:

  * **One AI-readable truth**
  * **Zero document conflict**
  * **Total deletion of legacy docs**

✅ That means **a single SSOT with strict internal namespacing is actually the *best* solution for your architecture.**

---

# ✅ The Correct Unified SSOT Structure (Deletion-Safe)

Your final file should look like this at the top:

```yaml
---
doc_id: DOC-SSOT-STATE-MACHINES-001
status: active
doc_type: ssot
scope:
  - orchestration
  - execution
  - validation
  - uet_v2
supersedes:
  - DOC_STATE_MACHINE.md
  - STATE_MACHINES.md
  - STATE_MACHINES (2).md
  - STATE_MACHINE (2).md
  - STATE_MACHINES (3).md
  - STATE_MACHINES (4).md
authoritative: true
---
```

Then the body must be **namespace-segmented** like this:

---

## SECTION 1 — ORCHESTRATION LAYER (Runtime Control)

### 1.1 Run State Machine

### 1.2 Workstream State Machine

### 1.3 Task State Machine

### 1.4 Orchestration Worker State Machine

### 1.5 Transition Enforcement & Invariants

### 1.6 Persistence Model (DB Constraints)

### 1.7 Event & Audit Model

### 1.8 Recovery & Manual Override Procedures

➡️ This absorbs:

* `DOC_STATE_MACHINE.md`
* `STATE_MACHINES.md`
* `STATE_MACHINES (2).md`
* `STATE_MACHINE (2).md`

---

## SECTION 2 — UET V2 EXECUTION ENGINE (Internal Enforcement)

### 2.1 UET Worker State Machine

### 2.2 Patch Ledger State Machine

### 2.3 Test Gate State Machine

### 2.4 Quarantine & Rollback Rules

### 2.5 Optimistic Locking & Concurrency

### 2.6 UET Database Constraints

### 2.7 UET Validation & Unit-Test Requirements

➡️ This absorbs:

* `STATE_MACHINES (3).md`
* `STATE_MACHINES (4).md`

---

## SECTION 3 — CROSS-SYSTEM DERIVATION & BINDINGS

This is what none of your current files explicitly formalize (and it *should*):

* How **task success triggers UET gate validation**
* How **UET gate failure blocks orchestration tasks**
* How **patch quarantine blocks workstreams**
* How **ledger state influences run outcome**
* How **rollback propagates back into orchestration**

This turns your SSOT into:

> **A full closed-loop execution truth model**

---

## SECTION 4 — SOURCE TRACEABILITY & DELETION RECORD

Here you permanently log:

| Legacy File           | Absorbed Into | Safe to Delete |
| --------------------- | ------------- | -------------- |
| DOC_STATE_MACHINE.md  | §1.1–§1.6     | ✅              |
| STATE_MACHINES.md     | §1.2, §1.8    | ✅              |
| STATE_MACHINE (2).md  | §1.3–§1.4     | ✅              |
| STATE_MACHINES (3).md | §2.1–§2.3     | ✅              |
| STATE_MACHINES (4).md | §2.1–§2.7     | ✅              |

This table is what gives you **legal-grade deletion safety**.

---

# ✅ When Can You Delete *All* Other State-Machine Files?

You may safely delete **every other state-machine file** only when **ALL 4 conditions below are true**:

1. ✅ The unified SSOT contains:

   * Run
   * Workstream
   * Task
   * Worker
   * Patch ledger
   * Test gates
2. ✅ All **DB constraints** from UET and orchestration are present
3. ✅ All **recovery procedures** are present
4. ✅ The SSOT header explicitly lists the files it supersedes

Once those are true → **100% safe deletion.**

---

# ✅ Final Verdict

| Question                                             | Answer      |
| ---------------------------------------------------- | ----------- |
| Can all state-machine files be merged into one SSOT? | ✅ YES       |
| Can that SSOT fully replace *every* existing file?   | ✅ YES       |
| Can the old files then be deleted?                   | ✅ YES       |
| Will this reduce conflict & AI confusion?            | ✅ MASSIVELY |
| Is there any architectural downside if namespaced?   | ❌ NO        |

---

# ⚠️ One Critical Rule

> **Do NOT flatten orchestration and UET machines into the same un-namespaced section.
> They must remain logically separated inside the SSOT.**

That is the only rule that preserves correctness.

---

## ✅ If You Want, I Can Now:

* Generate the **full unified `DOC-SSOT-STATE-MACHINES.md` shell** with every required section pre-built.
* Produce a **machine-readable JSON index** for the SSOT so your CLI can validate state transitions directly.
* Create a **PowerShell safe-merge + safe-delete workflow** that:

  1. Verifies coverage
  2. Archives legacy files
  3. Deletes only after validation

If you’d like, tell me which of those you want first.
