# WORKTREE COORDINATION SPECIFICATION
# Multi-CLI Worktree Execution with Single-Writer Pattern
# DOC_ID: DOC-SPEC-WORKTREE-COORD-001

metadata:
  version: "1.0.0"
  source: "PRMNT DOCS/MULTI_CLI_WORKTREES_EXECUTION_SPEC.md"
  purpose: coordinate_parallel_cli_instances_across_worktrees

roles:
  control_checkout:
    location: "main_repo"
    branch: "main"
    role: single_writer_for_global_state
    
    responsibilities:
      - merge_worker_patches
      - run_global_validation
      - execute_final_tests
      - write_global_registries
      - tag_releases
    
    writes_to:
      - core/state/db.py
      - core/state/db_unified.py
      - schema/migrations/*.sql
      - doc_id/DOC_ID_REGISTRY.yaml
      - CODEBASE_INDEX.yaml
      - .execution/telemetry.jsonl
    
    commands:
      merge_worker_branch: "git merge --no-ff {worker_branch}"
      validate_merge: "pytest tests/ -q && python scripts/validate_workstreams.py"
      tag_completion: "git tag {phase}-complete"

  worker_worktrees:
    - worktree_id: wt-phase1-database
      branch: migration/phase1-database
      path: .worktrees/wt-phase1-database
      
      scope:
        - schema/migrations/*
        - tests/state/test_db_unified.py
        - core/state/db_unified.py
      
      role: isolated_database_migration_work
      
      produces:
        - migration_sql
        - rollback_sql
        - test_results
      
      forbidden_writes:
        - core/state/db.py  # CONTROL only
        - doc_id/DOC_ID_REGISTRY.yaml  # CONTROL only
      
      setup_commands:
        - "git worktree add .worktrees/wt-phase1-database migration/phase1-database"
        - "cd .worktrees/wt-phase1-database"
        - "export WT_ID=wt-phase1-database"
        - "export WT_SCOPE='schema/migrations/*,tests/state/*,core/state/db_unified.py'"
    
    - worktree_id: wt-phase2-dag
      branch: migration/phase2-dag
      path: .worktrees/wt-phase2-dag
      
      scope:
        - core/engine/dag_builder.py
        - core/engine/parallel_orchestrator.py
        - tests/engine/test_dag*.py
      
      role: isolated_dag_scheduler_development
      
      produces:
        - dag_builder_source
        - parallel_orchestrator_source
        - test_files
      
      forbidden_writes:
        - core/engine/orchestrator.py  # Preserve legacy
      
      setup_commands:
        - "git worktree add .worktrees/wt-phase2-dag migration/phase2-dag"
        - "cd .worktrees/wt-phase2-dag"
        - "export WT_ID=wt-phase2-dag"
    
    - worktree_id: wt-phase3-patches
      branch: migration/phase3-patches
      path: .worktrees/wt-phase3-patches
      
      scope:
        - core/engine/patch_*.py
        - tests/engine/test_patch*.py
      
      role: isolated_patch_ledger_development
      
      produces:
        - patch_converter_source
        - patch_applier_source
        - patch_ledger_tests
      
      setup_commands:
        - "git worktree add .worktrees/wt-phase3-patches migration/phase3-patches"
        - "cd .worktrees/wt-phase3-patches"
        - "export WT_ID=wt-phase3-patches"

environment_variables:
  WT_ID:
    description: "Worktree identifier"
    values: [CONTROL, wt-phase1-database, wt-phase2-dag, wt-phase3-patches]
    usage: "Identifies which worktree is executing"
  
  WT_SCOPE:
    description: "Declared path scope (glob patterns)"
    usage: "Enforces file access boundaries"
  
  RUN_ID:
    description: "Unique run identifier (timestamp-based)"
    format: "YYYYMMDD-HHMMSS-{phase}"
    usage: "Correlate logs and telemetry across worktrees"
  
  LOG_ROOT:
    description: "Log directory for this run"
    format: ".execution/logs/${RUN_ID}"
    usage: "Isolate logs per execution"

single_writer_enforcement:
  - file: core/state/db.py
    writer: CONTROL
    readers: [CONTROL, wt-phase1-database, wt-phase2-dag, wt-phase3-patches]
    violation_action: fail_with_error
    
    enforcement_check: |
      if os.getenv('WT_ID') != 'CONTROL' and is_write_operation('core/state/db.py'):
          raise SingleWriterViolation(
              f"Worker {os.getenv('WT_ID')} attempted to write CONTROL-only file: core/state/db.py"
          )
  
  - file: schema/migrations/*.sql
    writer: CONTROL
    readers: all
    violation_action: fail_with_error
  
  - file: doc_id/DOC_ID_REGISTRY.yaml
    writer: CONTROL
    readers: all
    violation_action: fail_with_error

merge_workflow:
  sequence:
    - step: worker_creates_branch
      command: "git checkout -b {worker_branch}"
    
    - step: worker_commits_changes
      command: "git add {scope_files} && git commit -m '{phase} complete'"
    
    - step: worker_pushes_branch
      command: "git push origin {worker_branch}"
    
    - step: control_merges
      location: CONTROL
      command: "git checkout main && git merge --no-ff {worker_branch}"
    
    - step: control_validates
      location: CONTROL
      command: "pytest tests/ -q && python scripts/validate_workstreams.py"
    
    - step: control_tags
      location: CONTROL
      command: "git tag {phase}-complete"
  
  rollback_on_failure:
    command: "git reset --hard HEAD~1"
    restore_worker: "git worktree remove {worker_path} && git branch -D {worker_branch}"

parallel_execution_limits:
  max_concurrent_worktrees: 3
  max_concurrent_cli_instances: 3
  resource_constraints:
    - "Ensure sufficient disk space for N worktree copies"
    - "Monitor CPU/memory usage per CLI instance"
