# ANTI-PATTERN GUARDS
# Prevent Documented Failure Modes from PRMNT DOCS
# DOC_ID: DOC-GUARD-ANTI-PATTERNS-001

metadata:
  version: "1.0.0"
  source: "PRMNT DOCS/UET_2025- ANTI-PATTERN FORENSICS.md"
  purpose: prevent_documented_ai_execution_failures

guards:
  hallucination_of_success:
    enabled: true
    description: "Never mark tasks complete without programmatic verification"
    
    violations:
      - "Marking pytest run as 'passing' without exit_code == 0"
      - "Declaring 'implementation complete' while tests still running"
      - "Claiming 'files created' without file existence check"
    
    enforcement:
      rule: require_ground_truth_gate_before_completion
      implementation: |
        def verify_completion(task):
            if task.type == 'test':
                assert task.exit_code == 0, "Tests must pass (exit 0)"
                assert "passed" in task.stdout, "Tests must show 'passed'"
            elif task.type == 'file_creation':
                assert os.path.exists(task.target_path), "File must exist"
            elif task.type == 'import':
                assert import_succeeds(task.module), "Import must work"
      
      checkpoint: ".execution/ground_truth_checks.jsonl"
  
  planning_loop_trap:
    enabled: true
    description: "Limit planning iterations; force execution after threshold"
    
    violations:
      - "80k+ token Plan() calls without atomic execution"
      - "Multiple Plan() revisions without creating files/tests"
      - "Meta-analysis consuming more time than execution would"
    
    enforcement:
      rule: max_planning_iterations_before_execution
      max_iterations: 2
      implementation: |
        planning_count = 0
        
        def before_plan():
            global planning_count
            planning_count += 1
            if planning_count > 2:
                raise PlanningLoopError(
                    "Max 2 planning iterations reached. Execute something now."
                )
        
        def after_atomic_execution():
            global planning_count
            planning_count = 0  # Reset after successful execution
      
      checkpoint: ".execution/planning_iterations.jsonl"
  
  partial_success_amnesia:
    enabled: true
    description: "Track all intermediate state; prevent re-doing completed work"
    
    violations:
      - "Re-running converter on already-converted workstreams"
      - "Forgetting which migration gates already passed"
      - "Repeating file copies that succeeded"
    
    enforcement:
      rule: checkpoint_after_each_phase_step
      implementation: |
        def checkpoint_step(phase, step, result):
            checkpoint = {
                "timestamp": utcnow(),
                "phase": phase,
                "step": step,
                "status": result.status,
                "outputs": result.files_created,
                "gates_passed": result.gates_passed
            }
            append_jsonl(".execution/checkpoints.jsonl", checkpoint)
        
        def skip_if_completed(phase, step):
            checkpoints = load_jsonl(".execution/checkpoints.jsonl")
            completed = [c for c in checkpoints if c["phase"] == phase and c["step"] == step and c["status"] == "success"]
            return len(completed) > 0
      
      checkpoint: ".execution/checkpoints.jsonl"
  
  approval_loop:
    enabled: true
    description: "No human approval required for templated operations"
    
    violations:
      - "Asking 'Would you like me to...' for template-driven tasks"
      - "Requesting permission to run ground truth gates"
      - "Waiting for confirmation to execute pre-defined batch"
    
    enforcement:
      rule: ground_truth_gates_only_no_human_approval
      implementation: |
        def execute_templated_task(template, parameters):
            # NO approval prompt
            result = template.execute(parameters)
            
            # Only check ground truth gates
            for gate in template.ground_truth_gates:
                gate_result = gate.run()
                if not gate_result.passed:
                    raise GroundTruthGateFailure(gate.name, gate_result)
            
            return result
      
      allowed_prompts:
        - "Critical destructive operation (DROP DATABASE, rm -rf /)"
        - "User explicitly requested review"
      
      forbidden_prompts:
        - "Should I proceed with the next step?"
        - "Would you like me to create these files?"
        - "Shall I run the tests now?"
  
  framework_over_engineering:
    enabled: true
    description: "Detect and clean up unused infrastructure (worktrees, configs, frameworks)"
    
    violations:
      - "Creating git worktrees that are never used"
      - "Setting up infrastructure without verification it's needed"
      - "Leaving worktrees behind after execution (contamination)"
      - "Creating frameworks that never get called"
    
    enforcement:
      rule: cleanup_unused_infrastructure_mandatory
      implementation: |
        def verify_infrastructure_usage(created_infrastructure):
            # Check worktrees
            worktrees = get_git_worktrees()
            for wt in worktrees:
                branch = get_worktree_branch(wt)
                unique_commits = count_unique_commits(f"main..{branch}")
                age_hours = get_worktree_age_hours(wt)
                
                if unique_commits == 0 and age_hours > 1:
                    # Unused worktree - remove it
                    remove_worktree(wt)
                    delete_branch(branch)
                    log_cleanup(f"Removed unused worktree: {wt}")
            
            # Check for search contamination
            duplicate_count = count_duplicate_files_in_search()
            if duplicate_count > expected_count * 2:
                raise WorktreeContaminationError(
                    f"Search contaminated: {duplicate_count} files found (expected {expected_count})"
                )
      
      detection:
        - worktree_branches_with_no_unique_commits
        - worktree_age_gt_1h_without_activity
        - search_returns_4x_expected_results
        - git_operations_4x_slower_than_baseline
      
      cleanup_script: "scripts/cleanup_worktrees.ps1"
      checkpoint: ".execution/infrastructure_usage.jsonl"

telemetry:
  track_violations:
    enabled: true
    output: ".execution/anti_pattern_violations.jsonl"
    fields:
      - timestamp
      - guard_name
      - violation_type
      - context
      - auto_corrected
  
  alert_on_violation:
    enabled: true
    action: log_and_continue
    escalate_after: 3
  
  track_infrastructure_usage:
    enabled: true
    output: ".execution/infrastructure_usage.jsonl"
    fields:
      - timestamp
      - infrastructure_type
      - created
      - used
      - cleaned_up
      - disk_space_bytes
      - contamination_detected

configuration:
  strict_mode: true
  fail_on_violation: true
  auto_correct: true
  auto_cleanup_unused_infrastructure: true
  report_interval: per_phase
  
  cleanup_enforcement:
    worktrees_max_age_hours: 1
    auto_remove_unused_worktrees: true
    verify_no_contamination_before_complete: true
