
● Comprehension Summary

  Document Type: Development plan and architecture specification for a
  patch-based inter-tool communication system.

  Core Innovation: Transforms file passing from "tools directly modify
  files" to "tools generate patches as explicit change contracts" with
  validation gates and full audit trail.

  7 Development Sections (and their connections):

  | Section                          | Purpose
                             | Key Dependencies
    |
  |----------------------------------|--------------------------------------
  ---------------------------|----------------------------------------------
  --|
  | 1. Task Router                   | Routes tasks to appropriate tools
                             | Reads from §2, delegates to §3, enforces §6
    |
  | 2. Task Queue                    | File-based queue lifecycle
  (inbox→running→done/failed)          | Feeds §1, stores payloads for §3
              |
  | 3. App Adapters                  | Tool-specific CLI execution (Aider,
  Codex, Claude)              | Uses prompts from §4, generates patches for
  §5 |
  | 4. Prompt Engine                 | Renders WORKSTREAM_V1.1 templates
  with classification inference | Feeds §3, influences §1 routing
       |
  | 5. Patch Manager                 | Capture/validate/apply unified diffs,
   store in .ledger/patches/ | Validates via §6, logged by §7
    |
  | 6. Validation & Circuit Breakers | Scope validation, oscillation
  detection (diff hash), timeouts   | Gates §5, blocks §1 on trips
           |
  | 7. Audit & Telemetry             | JSONL logging, patch ledger, metrics
                             | Receives events from all sections
    |

  Three Task Modes:
  - prompt: Traditional—tool receives files, makes changes
  - patch_review: Tool receives pre-generated patch, reviews without editing
  - patch_apply_validate: Tool applies patch in isolation, runs tests,
  reports back

  Development Phases: Foundation (queue/patches/audit) → Routing → Prompts
  V1.1 → Validation → Integration

  I confirm full comprehension of this plan. Ready for implementation
  guidance or specific section development.

> create detailed phase by phase plan for develoment by agentic ai app, take
 time to ultrathink before you respond.

● Detailed Phase-by-Phase Development Plan

  Based on deep analysis of the architecture and dependencies, here's a
  comprehensive plan optimized for agentic AI execution:

  ---
  Phase 0: Pre-Flight & Schema Setup

  Objective: Establish database schema and directory structure before any
  code

  Tasks:
  1. Create directory structure:
    - .tasks/inbox/, .tasks/running/, .tasks/done/, .tasks/failed/
    - .ledger/patches/
    - .runs/ (for audit logs)
  2. Create database migration:
    - schema/migrations/001_add_patches_table.sql
    - Add patches table with columns: id, run_id, ws_id, step_name, attempt,
   patch_file, diff_hash, line_count, files_modified, created_at, validated,
   applied
    - Add index on (ws_id, diff_hash) for oscillation detection
  3. Create configuration skeleton:
    - config/router.config.yaml with empty apps and routing sections

  Acceptance Criteria: Directories exist, migration applies cleanly, config
  validates

  ---
  Phase 1A: Task Queue Management (Section 2)

  Objective: File-based task lifecycle management

  Files to Create:
  - core/state/task_queue.py

  Implementation Details:
  # Key classes and methods:
  class Task:
      task_id: str              # ULID
      source_app: str           # "codex", "claude", "aider", "human"
      mode: str                 # "prompt" | "patch_review" |
  "patch_apply_validate"
      capabilities: List[str]   # ["refactor", "python", "tests"]
      payload: TaskPayload      # Files, repo_path, description, patch_file
      constraints: TaskConstraints
      timeouts: TaskTimeouts
      routing_state: RoutingState

  class TaskQueue:
      def enqueue(task: Task) -> str
      def dequeue() -> Optional[Task]
      def peek() -> List[Task]
      def move_to_running(task_id: str)
      def complete(task_id: str, result: TaskResult)
      def fail(task_id: str, error: str)
      def get_status(task_id: str) -> TaskStatus

  Test Plan:
  - Unit: enqueue/dequeue cycle, concurrent access, file locking
  - Integration: Task persists across process restart

  ---
  Phase 1B: Audit & Telemetry Foundation (Section 7)

  Objective: Structured logging infrastructure

  Files to Create:
  - core/state/audit_logger.py

  Implementation Details:
  class AuditLogger:
      def __init__(self, log_path: Path = ".runs/audit.jsonl")
      def log_event(event_type: str, task_id: str, data: Dict)
      def query_events(filters: EventFilters) -> List[AuditEvent]

  class PatchLedger:
      def __init__(self, ledger_path: Path = ".ledger/patches")
      def store_patch(patch: PatchArtifact) -> Path
      def get_patch(patch_id: str) -> PatchArtifact
      def get_history(ws_id: str) -> List[PatchArtifact]

  Event Types to Support:
  task_received, task_routed, process_started, patch_captured,
  patch_validated, patch_applied, scope_violation, oscillation_detected,
  circuit_breaker_trip, completed, failed

  Test Plan:
  - Unit: Log rotation, JSON serialization, query filtering
  - Integration: Events queryable after write

  ---
  Phase 2: Patch Management System (Section 5)

  Objective: Core patch lifecycle—capture, store, parse, apply

  Files to Create:
  - core/engine/patch_manager.py

  Files to Modify:
  - core/state/db.py - Add patch CRUD operations
  - core/state/crud.py - Add record_patch(), get_patches_by_ws()

  Implementation Details:
  class PatchManager:
      def capture_patch(run_id: str, ws_id: str, worktree_path: str) ->
  PatchArtifact
          # 1. git diff --no-ext-diff in worktree
          # 2. Parse to extract modified files
          # 3. Compute SHA256 diff_hash
          # 4. Store to .ledger/patches/{ws_id}-{run_id}.patch
          # 5. Record in database
          # 6. Log to audit

      def parse_patch(patch_file: Path) -> PatchParseResult
          # Extract: files_modified, hunks, line counts

      def apply_patch(patch_file: Path, target_path: str) -> ApplyResult
          # 1. git apply --check (dry run)
          # 2. git apply if OK
          # 3. Return success/failure with details

      def reverse_patch(patch_file: Path, target_path: str) -> ApplyResult

  class PatchArtifact:
      patch_id: str
      patch_file: Path
      diff_hash: str          # SHA256 for oscillation
      files_modified: List[str]
      line_count: int
      created_at: str

  Test Plan:
  - Unit: Parse unified diff format, hash consistency
  - Integration: Capture → store → retrieve → apply cycle
  - Edge cases: Empty diff, binary files, path with spaces

  ---
  Phase 3: Prompt Engine V1.1 (Section 4)

  Objective: WORKSTREAM_V1.1 template rendering with classification
  inference

  Files to Create:
  - core/engine/prompt_engine.py
  - aider/templates/prompts/workstream_v1.1_universal.txt.j2
  - aider/templates/prompts/workstream_v1.1_aider.txt.j2
  - aider/templates/prompts/workstream_v1.1_codex.txt.j2

  Files to Modify:
  - aider/engine.py - Add V1.1 rendering support

  Implementation Details:
  class PromptEngine:
      def render_v11(bundle: Dict, context: PromptContext) -> str
          # 1. Infer classification if not explicit
          # 2. Infer role/persona from domain + complexity
          # 3. Select template variant based on target_app
          # 4. Populate all V1.1 sections
          # 5. Return ASCII-only rendered prompt

      def _infer_classification(bundle: Dict) -> Classification
          # Analyze: file count, task complexity, dependencies
          # Return: complexity_level, quality_level, domain

      def _infer_role(classification: Classification) -> str
          # Map to persona: "Senior Python engineer specializing in..."

      def _select_template(target_app: str) -> str
          # "universal" | "aider" | "codex" | "claude"

  class Classification:
      complexity: str    # simple|moderate|complex|enterprise
      quality: str       # standard|production
      domain: str        # code|docs|tests|analysis
      operation: str     # refactor|bugfix|feature|analysis_only

  Template Structure (V1.1 sections):
  [HEADER] -> [OBJECTIVE] -> [CONTEXT] -> [FILE_SCOPE] -> [TASKS]
  -> [CONSTRAINTS] -> [OUTPUT_FORMAT] -> [VALIDATION] -> [NEXT_STEPS]
  -> [EXECUTION_HINTS]  # Tool-specific, optional

  Test Plan:
  - Unit: Classification inference accuracy, template rendering
  - Integration: Bundle → prompt → validates against V1.1 schema
  - Regression: Existing bundles render correctly

  ---
  Phase 4: Validation & Circuit Breakers (Section 6)

  Objective: Safety gates—scope validation, oscillation detection, timeouts

  Files to Create:
  - core/engine/validators.py

  Files to Modify:
  - core/engine/circuit_breakers.py - Add oscillation detection

  Implementation Details:
  # core/engine/validators.py
  class ScopeValidator:
      def validate_patch_scope(patch: PatchArtifact, bundle: Dict) -> 
  ScopeResult
          # 1. Get allowed files from bundle.files_scope + files_may_create
          # 2. Compare against patch.files_modified
          # 3. Return violations or OK

  class TimeoutMonitor:
      def watch_process(proc: Popen, wall_sec: int, idle_sec: int) -> 
  TimeoutResult
          # 1. Track total runtime
          # 2. Track time since last stdout/stderr
          # 3. Kill if exceeded, return reason

  # core/engine/circuit_breakers.py (MODIFY)
  class CircuitBreaker:
      def check_oscillation(ws_id: str, diff_hash: str) -> Optional[Trip]
          # 1. Query last N patches for ws_id from database
          # 2. Count occurrences of diff_hash
          # 3. If >= threshold (default 2): trip

      def should_stop(run_id, ws_id, step, attempt, 
                      error_sig=None, diff_hash=None) -> Optional[Trip]
          # Unified check: attempts + error_sig + oscillation

  Test Plan:
  - Unit: Scope violations detected, oscillation threshold triggers
  - Integration: Patch with out-of-scope file blocked
  - Edge cases: Exact threshold boundary, hash collision handling

  ---
  Phase 5: App Adapters (Section 3)

  Objective: Tool-specific execution wrappers

  Files to Create:
  - core/engine/adapters/__init__.py
  - core/engine/adapters/base.py
  - core/engine/adapters/aider_adapter.py
  - core/engine/adapters/codex_adapter.py
  - core/engine/adapters/claude_adapter.py

  Files to Modify:
  - config/tool_profiles.json - Add adapter configurations

  Implementation Details:
  # core/engine/adapters/base.py
  class ToolAdapter(ABC):
      @abstractmethod
      def build_command(task: Task) -> List[str]

      @abstractmethod
      def execute(cmd: List[str], timeout: int) -> ToolResult

      def execute_task(task: Task) -> ToolResult
          # 1. Build command
          # 2. Execute with timeout monitoring
          # 3. Capture output
          # 4. Return result

  # core/engine/adapters/aider_adapter.py
  class AiderAdapter(ToolAdapter):
      def build_command(task: Task) -> List[str]:
          if task.mode == "prompt":
              return ["aider", "--yes", "--no-tty",
                      "--message-file", task.payload.prompt_file,
                      *task.payload.files]
          elif task.mode == "patch_apply_validate":
              # Different flow for patch application
              pass

      def execute(cmd: List[str], timeout: int) -> ToolResult:
          # Run subprocess with PYTHONIOENCODING=utf-8
          # Apply timeout monitoring
          # Return ToolResult with stdout, stderr, exit_code

  Test Plan:
  - Unit: Command building for each mode, timeout handling
  - Integration: Aider executes simple edit task
  - Mock: Test adapter logic without actual CLI calls

  ---
  Phase 6: Task Router & Orchestrator Integration (Section 1)

  Objective: Central routing logic and orchestrator integration

  Files to Create:
  - core/engine/task_router.py
  - core/engine/routing_policy.py

  Files to Modify:
  - core/engine/orchestrator.py - Integrate router
  - config/router.config.yaml - Populate with apps and rules

  Implementation Details:
  # core/engine/task_router.py
  class TaskRouter:
      def __init__(self, config_path: str)
          self.config = load_yaml(config_path)
          self.app_registry = AppRegistry(self.config['apps'])
          self.routing_policy = RoutingPolicy(self.config['routing'])

      def route_task(task: Task) -> ToolSelection
          # 1. Check if task allows delegation
          # 2. Match capabilities to registered apps
          # 3. Apply routing policy rules
          # 4. Return primary + fallback + reason

      def execute_routed_task(task: Task) -> TaskResult
          # 1. Route task
          # 2. Get adapter for selected tool
          # 3. Execute via adapter
          # 4. Capture patch
          # 5. Validate patch scope
          # 6. Check circuit breakers
          # 7. Apply or reject

  # core/engine/routing_policy.py
  class RoutingPolicy:
      def select_tool(task: Task, available: List[str]) -> str
          # Apply rules: capability match, load balancing, preferences

  class ToolSelection:
      primary: str
      fallback: Optional[str]
      reason: str

  Config Structure (router.config.yaml):
  apps:
    aider:
      capabilities: [refactor, python, edit]
      priority: 1
    codex:
      capabilities: [generate, multifile, autonomous]
      priority: 2
    claude:
      capabilities: [review, analysis, complex_reasoning]
      priority: 3

  routing:
    default_tool: aider
    capability_overrides:
      review: claude
      autonomous: codex
    fallback_chain: [aider, codex, claude]

  Test Plan:
  - Unit: Routing rules, capability matching, fallback selection
  - Integration: End-to-end task → route → execute → patch → validate
  - Scenario: Fallback triggers on primary failure

  ---
  Phase 7: Integration & Polish

  Objective: End-to-end workflows, CLI entry points, metrics

  Files to Create:
  - scripts/submit_task.py - CLI task submission
  - scripts/task_status.py - Query task status
  - scripts/workstream_metrics.py - Metrics dashboard

  Files to Modify:
  - scripts/run_workstream.py - Use new router
  - Existing PowerShell scripts - Add task mode support

  Implementation Details:

  1. CLI Entry Point:
  python scripts/submit_task.py \
    --source codex \
    --mode prompt \
    --files src/module.py \
    --description "Refactor for clarity"

  2. Metrics Collection:
  class MetricsCollector:
      def compute_metrics(days: int = 7) -> Metrics
          # - First-pass success rate by tool
          # - Average fix attempts per workstream
          # - Circuit breaker trip reasons
          # - Execution time distributions

  3. PowerShell Integration:
  # scripts/SubmitTask.ps1 enhancement
  param(
      [string]$Tool,
      [string]$Mode,           # NEW
      [string]$PatchFile,      # NEW
      [string[]]$ValidationCommands  # NEW
  )

  Test Plan:
  - End-to-end: Codex → patch → Claude reviews → Aider applies → validated →
   committed
  - Performance: 100 tasks through queue
  - Metrics: Dashboard shows accurate data

  ---
  Dependency Graph Summary

  Phase 0 (Schema)
      ↓
  Phase 1A (Queue) ←→ Phase 1B (Audit)  [parallel]
      ↓                    ↓
           Phase 2 (Patches)
                ↓
      Phase 3 (Prompts)  ←→  Phase 4 (Validation)  [can parallel]
                ↓                    ↓
                Phase 5 (Adapters)
                     ↓
                Phase 6 (Router)
                     ↓
                Phase 7 (Integration)

  ---
  Files Summary

  New Files (18):
  - core/state/task_queue.py
  - core/state/audit_logger.py
  - core/engine/patch_manager.py
  - core/engine/prompt_engine.py
  - core/engine/validators.py
  - core/engine/task_router.py
  - core/engine/routing_policy.py
  - core/engine/adapters/__init__.py
  - core/engine/adapters/base.py
  - core/engine/adapters/aider_adapter.py
  - core/engine/adapters/codex_adapter.py
  - core/engine/adapters/claude_adapter.py
  - aider/templates/prompts/workstream_v1.1_*.j2 (3 files)
  - schema/migrations/001_add_patches_table.sql
  - config/router.config.yaml
  - scripts/submit_task.py
  - scripts/task_status.py

  Modified Files (7):
  - core/state/db.py
  - core/state/crud.py
  - core/engine/circuit_breakers.py
  - core/engine/orchestrator.py
  - aider/engine.py
  - config/tool_profiles.json
  - scripts/run_workstream.py

  ---
  ⎿  User rejected Claude's plan:
     ╭─────────────────────────────────────────────────────────────────────────╮
     │ Development Plan: Patch-Based CLI Tool Integration                      │
     │                                                                         │
     │ Phase 0: Pre-Flight & Schema Setup                                      │
     │                                                                         │
     │ - Create directories: .tasks/{inbox,running,done,failed}/,              │
     │ .ledger/patches/, .runs/                                                │
     │ - Create schema/migrations/001_add_patches_table.sql                    │
     │ - Create config/router.config.yaml skeleton                             │
     │                                                                         │
     │ Phase 1A: Task Queue (parallel with 1B)                                 │
     │                                                                         │
     │ - Create core/state/task_queue.py                                       │
     │ - Implement: Task, TaskQueue with enqueue/dequeue/complete/fail         │
     │                                                                         │
     │ Phase 1B: Audit & Telemetry (parallel with 1A)                          │
     │                                                                         │
     │ - Create core/state/audit_logger.py                                     │
     │ - Implement: AuditLogger, PatchLedger with JSONL logging                │
     │                                                                         │
     │ Phase 2: Patch Management                                               │
     │                                                                         │
     │ - Create core/engine/patch_manager.py                                   │
     │ - Modify core/state/db.py, crud.py for patch CRUD                       │
     │ - Implement: capture, parse, apply, reverse patches with diff_hash      │
     │                                                                         │
     │ Phase 3: Prompt Engine V1.1                                             │
     │                                                                         │
     │ - Create core/engine/prompt_engine.py                                   │
     │ - Create 3 Jinja templates: universal, aider, codex variants            │
     │ - Implement: classification inference, role inference, V1.1 rendering   │
     │                                                                         │
     │ Phase 4: Validation & Circuit Breakers                                  │
     │                                                                         │
     │ - Create core/engine/validators.py                                      │
     │ - Modify core/engine/circuit_breakers.py                                │
     │ - Implement: scope validation, oscillation detection, timeout           │
     │ monitoring                                                              │
     │                                                                         │
     │ Phase 5: App Adapters                                                   │
     │                                                                         │
     │ - Create core/engine/adapters/ with base + 3 tool adapters              │
     │ - Implement: command building, headless execution, output capture       │
     │                                                                         │
     │ Phase 6: Task Router & Integration                                      │
     │                                                                         │
     │ - Create core/engine/task_router.py, routing_policy.py                  │
     │ - Modify core/engine/orchestrator.py                                    │
     │ - Implement: capability routing, fallback chains, full task lifecycle   │
     │                                                                         │
     │ Phase 7: Integration & Polish                                           │
     │                                                                         │
     │ - Create CLI scripts: submit_task.py, task_status.py                    │
     │ - Create metrics: workstream_metrics.py                                 │
     │ - End-to-end testing: multi-tool workflow                               │
     │                                                                         │
     │ Total: 18 new files, 7 modified files                                   │
     ╰─────────────────────────────────────────────────────────────────────────╯



