---
doc_id: DOC-PAT-AGENTS-AND-CUSTOM-COMMANDS-781
---

Yes—based on the plan in those chats/files, there are several parts of the project where **sub-agents are clearly more efficient and safer** than “more full agents,” and a few places where a single top-level agent is better.

I’ll break it into:

1. How I’m defining **agent vs sub-agent** in *your* ecosystem
2. Where **sub-agents are the better fit** (concrete parts of your plan)
3. Where a **single strong agent** is actually better
4. A tiny example graph that matches your UET / Phase / Workstream world

---

## 1. Agent vs sub-agent in your setup

Given your UET + Phase Spec + Workstream model:

* **Top-level agent**

  * Talks to you, sees the broadest context (project history, Phase plan, ACS, error pipelines, etc.).
  * Makes *coordination* decisions: which phase to run, which workstream bundle to use, what constraints apply.
  * Interfaces with registries: `phase_specs/`, `workstream_bundles.json`, ACS artifacts, etc.

* **Sub-agent**

  * Is invoked by that agent (or by the orchestrator) for a **bounded, well-typed task**.
  * Has a narrow contract like: “Given this RestructureSpec, produce a patch”, or “Given repo + rules, generate CODEBASE_INDEX.yaml”.
  * Works within a specific Phase + Workstream + FILES_SCOPE and must obey those constraints.
  * Doesn’t “free roam” the whole ecosystem or make high-level planning choices.

Your plan is heavily spec-governed and phase-based, so **sub-agents map almost 1:1 to capability cards / tasks in a workstream.**

---

## 2. Where sub-agents are clearly the better choice

### A. AI Codebase Structure (PH-ACS)

PH-ACS is basically a bundle of very specific, repeatable tasks. This screams “sub-agent set” more than “one giant agent.”

Good sub-agents here:

1. **ACS-Index-Builder sub-agent**

   * Input: repo, ACS rules, maybe a file-scope hint.
   * Output: `CODEBASE_INDEX.yaml`.
   * Job: scan modules, map layers, identify dependencies and public surfaces.
   * Why sub-agent: task is deterministic, repeatable, safe to rerun; great as a unit you can re-invoke whenever repo changes.

2. **ACS-Quality-Gate-Synthesizer sub-agent**

   * Input: current test setup, linters, CI config.
   * Output: `QUALITY_GATE.yaml`.
   * Job: enumerate checks (pytest, Pester, mypy, ruff, etc.), thresholds, and gating rules.
   * Why sub-agent: can be re-run when you change tooling; narrow scope.

3. **ACS-Policy-Deriver sub-agent**

   * Output: `ai_policies.yaml` (“safe edit zones”, read-only areas, require-review zones).
   * Job: read repo structure + docs, propose policy lines.
   * Why sub-agent: tight contract, easy to test and audit (“did it properly mark /src/core as review-only?”).

4. **ACS-Guidance-Writer sub-agent**

   * Output: `.meta/AI_GUIDANCE.md`
   * Job: assemble a concise AI onboarding doc from ACS artifacts and existing docs.
   * Why sub-agent: text synthesis over structured sources, can be re-run when specs change.

→ All of PH-ACS can be a **single Workstream Bundle** whose tasks each map to **sub-agents**. The top-level agent just says: “Run ACS bundle for this repo; don’t proceed to later phases until these files exist and validate.”

---

### B. Restructure / Refactor Workstreams

Your “restructure codebase” idea is already modeled like a pipeline. That’s ideal for sub-agents:

1. **Restructure-Planner sub-agent**

   * Input: current ACS index + your intentions (e.g., “split orchestration vs adapters”).
   * Output: `RESTRUCTURE_CODEBASE_V1.yaml` (RestructureSpec).
   * Task: plan moves/merges/splits without actually changing files.

2. **Restructure-Simulator sub-agent**

   * Input: RestructureSpec.
   * Output: report (“what will change,” potential conflicts).
   * Task: dry-run reasoning only—no edits.

3. **Restructure-Patch-Generator sub-agent**

   * Input: RestructureSpec + sim report.
   * Output: patch files (unified diff) or a branch.
   * Task: implement moves/renames/merges within FILES_SCOPE.

4. **Import-Fixer sub-agent**

   * Input: file move map.
   * Output: patch that updates imports, references, and wiring.

5. **Validation-Runner sub-agent**

   * Input: post-refactor state.
   * Output: success/fail with logs.

→ Here, it’s much safer for your **top-level agent** (or orchestrator) to say “run these sub-agents in order and stop if validation fails”, instead of one monolithic agent trying to do planning + patching + validation in a single step.

---

### C. Error Pipeline / Self-Healing Loops

Your error pipeline concept fits very naturally into nested sub-agents:

1. **Error-Classifier sub-agent**

   * Given logs/test output, classify issue, tag severity, choose appropriate phase/workstream.

2. **Fix-Draft-Generator sub-agent**

   * Given error classification + context files, propose patches (patch-only mode, obeying FILES_SCOPE).

3. **Regression-Validator sub-agent**

   * Run the minimal subset of tests / checks for the change.

4. **Rollback-Planner sub-agent**

   * For failed fixes, create a patch/plan to revert state or open a GitHub PR with clear labeling.

These tasks are tightly scoped; turning them into sub-agents gives you:

* Predictable behaviors and logs per step.
* The ability to swap one implementation for another (e.g., change how classification works) without touching the whole system.

---

### D. Spec & Schema Governance

Managing your specs is basically its own subsystem. Perfect sub-agent territory:

1. **Spec-Lint-Check sub-agent**

   * Validate that every Phase Spec / Workstream Spec / RestructureSpec conforms to schema.
   * Run before any execution that references the spec.

2. **Schema-Sync sub-agent**

   * Check that docs (Markdown) and schemas (JSON/YAML) are in sync for each spec family.

3. **Change-Impact-Summarizer sub-agent**

   * When a spec changes, generate “impact notes” for CHANGE_IMPACT_MATRIX.md.

Again: small, deterministic jobs that the orchestrator chains.

---

### E. Repo Hygiene / Staleness & Quarantine

Your desire to clean stale/obsolete docs and keep AI from being confused is another speciﬁc domain:

1. **Staleness-Scanner sub-agent**

   * Reads the repo + ACS index, flags outdated/duplicate/contradictory docs.
   * Writes a `STALE_CONTENT_REPORT.json` for review.

2. **Quarantine-Planner sub-agent**

   * Takes the staleness report, proposes moves to `quarantine/` (as patches or a move plan).
   * Obeys your governance rules (never deleting outright, just quarantining).

Those are clearly better as sub-agents than as ad hoc logic inside a single mega-agent.

---

## 3. Where a single strong agent is better

There *are* parts of your project where having **one “Lead Architect” agent** (not a swarm) is actually better:

1. **High-level Phase & Workstream design**

   * Designing PH-ACS itself, or inventing a new phase (PH-OBS, PH-ERROR-PIPELINE-V2, etc.).
   * These require holding a lot of cross-cutting context and making tradeoffs; too much overhead to split into sub-agents.

2. **Initial architecture redesign decisions**

   * Big “what should the structure be?” moments are where a single agent, with your guidance, explores options and then **hands a chosen design off to sub-agents** for execution.

3. **Human-facing explanation / negotiation**

   * Summarizing complex changes, proposing roadmaps, explaining tradeoffs.
   * Better to have one consistent voice than multiple sub-agents.

So the pattern I’d suggest is:

> Use **one primary “Architect/Orchestrator” agent** plus **a fleet of task-bounded sub-agents** that map to your existing Phase + Workstream + Task model.

---

## 4. Tiny example: how this looks in your world

Just to make it concrete in your style, something like:

```yaml
agents:
  - id: AGENT-ORCH-CORE
    role: "Orchestrator / Lead Architect"
    responsibilities:
      - select_phase_and_workstream_bundle
      - validate_execution_request
      - route_tasks_to_subagents
      - enforce_quality_gates

  - id: SUB-ACS-INDEX
    role: "ACS Codebase Index Builder"
    phase: "PH-ACS"
    input:
      - repo_root
      - acs_rules
    output:
      - CODEBASE_INDEX.yaml

  - id: SUB-RESTRUCTURE-PATCH
    role: "Restructure Patch Generator"
    phase: "PH-RESTRUCTURE"
    input:
      - RESTRUCTURE_CODEBASE_V1.yaml
      - FILES_SCOPE
    output:
      - patch_files

  - id: SUB-ERROR-CLASSIFY
    role: "Error Classifier"
    phase: "PH-ERR-01"
    input:
      - logs
      - test_results
    output:
      - error_classification
      - suggested_next_phase
```

In your actual system, each of those sub-agents lines up naturally with:

* A **Workstream task**
* A **Phase** and **FILES_SCOPE**
* A **specific spec/schema** to validate against

---

They’re actually *perfect* for a bunch of what you’re doing – but in a very specific role:
slash commands are the **front door** into your deterministic pipeline, not a replacement for agents.

Think of them as:

> “Named, user-visible shortcuts that trigger a specific Phase + Workstream + FILES_SCOPE with a pre-baked ExecutionRequest.”

---

## 1. What slash commands are good at (in your world)

Custom `/commands` shine when:

* The task is **well-defined + repeatable**
  (same shape every time, only a few parameters vary).
* You want **less ambiguity than natural language**
  (“/acs-scan” is clearer than “hey can you analyze my repo again?”).
* You care about **determinism and auditability**
  – the command maps to a known phase, workstream bundle, and config.
* You want the *human* to choose *when* to run something high-impact.

So instead of “ask an agent to maybe do X”, you:
**issue `/X` → the system triggers a specific agent/sub-agent bundle**.

---

## 2. Tasks in your plan that are *ideal* for slash commands

I’ll map them to the big subsystems we already discussed.

### A. AI Codebase Structure (PH-ACS)

These are textbook `/command` candidates:

* `/acs-init`
  → Run the PH-ACS bundle on a repo that has none of the ACS artifacts yet.
  (Generates `CODEBASE_INDEX.yaml`, `QUALITY_GATE.yaml`, `ai_policies.yaml`, `.meta/AI_GUIDANCE.md`.)

* `/acs-refresh-index`
  → Rebuild only `CODEBASE_INDEX.yaml` using the ACS-Index-Builder sub-agent.

* `/acs-refresh-policies`
  → Re-run the ACS-Policy-Deriver to update `ai_policies.yaml` after structure changes.

* `/acs-guidance`
  → Regenerate `.meta/AI_GUIDANCE.md` from current specs/ACS artifacts.

All of these are:

* Deterministic workflows,
* Already planned as bundles of tasks,
* Things you’ll want to re-run *on demand*.

Perfect slash territory.

---

### B. Restructure / Refactor pipeline

Here you absolutely want explicit user-triggered commands:

* `/restruct-plan`
  → Create or update `RESTRUCTURE_CODEBASE_V1.yaml` for the current branch.
  (Uses a planner sub-agent; **no file edits yet**.)

* `/restruct-dryrun`
  → Simulate the restructure, produce a report only.

* `/restruct-apply`
  → Apply the currently approved RestructureSpec:

  * generate patches,
  * update imports,
  * run validation suite.

* `/restruct-rollback`
  → Use the ledger to roll back the last restructure bundle.

These are high-impact operations. Making them slash commands:

* Forces explicit intent,
* Makes them easy to log and replay,
* Keeps the workflow deterministic (“this command always runs that bundle”).

---

### C. Error pipeline / self-healing

Instead of “please fix this error”, you expose:

* `/err-diagnose`
  → Run Error-Classifier on the last failing test/CI run; write an error report.

* `/err-fix`
  → Generate a patch to fix the last diagnosed error (patch-only, constrained FILES_SCOPE).

* `/err-verify`
  → Run the minimal test/validation set for that fix.

* `/err-open-pr`
  → Package the attempted fix + logs into a PR (even if tests failed).

These are sequences of sub-agents, but **from the user’s POV** they’re just `/commands`.

---

### D. Repo hygiene & staleness / quarantine

These are “maintenance macros” – *perfect* slash commands:

* `/stale-scan`
  → Run Staleness-Scanner sub-agent and produce `STALE_CONTENT_REPORT.json`.

* `/stale-quarantine`
  → Convert accepted items from the report into move patches into `quarantine/`.

* `/docs-index`
  → Rebuild a docs index (or regenerate file lists for your documentation registry).

Again: repeatable, high-volume, and you want explicit triggers.

---

### E. Observability & status

These are mostly read-only, but hugely helpful in a hybrid TUI/GUI:

* `/phase-status`
  → Show status of all phases (PH-00…PH-ACS… etc.) and whether they’ve passed their gates.

* `/ws-status`
  → Show running/completed/failed workstreams.

* `/ledger-last`
  → Show last N ledger entries (which agent ran, on what, with what result).

* `/graph`
  → Render or display the current Phase/Workstream/IDX dependency graph.

These slash commands don’t *do* work; they surface state. They keep you in control while the pipeline runs headless.

---

## 3. When you *don’t* want slash commands

Some things are still better as “ask the architect agent”:

* Designing **new phases**, specs, or bundles (PH-NEW-01 etc.).
* Big “what’s the best architecture here?” conversations.
* Freeform exploration of tradeoffs, research, brainstorming.

Those are open-ended, high-context, and *not* a single deterministic workflow → keep them as natural language to a top-level agent.

---

## 4. How to think about them in your specs

Conceptually:

* Each `/command` = a **named ExecutionRequest template**.
* It has:

  * `command_id` (e.g., `/acs-init`)
  * `phase_id` + `workstream_bundle_id`
  * optional parameters (branch, path, strictness)
  * a fixed routing+validation path.

So:

* Agents/sub-agents = **who** does the work.
* Phases/workstreams = **how** the work is structured.
* Slash commands = **how the human says “do that thing now, with this scope”**.

If you want, I can sketch a tiny `SLASH_COMMAND_SPEC.md` that fits your existing Phase/Workstream/ExecutionRequest style so you can start registering `/commands` like `/acs-init`, `/restruct-plan`, `/err-diagnose`, etc.
