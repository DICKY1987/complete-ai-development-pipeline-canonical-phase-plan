---
doc_id: DOC-PAT-TERMINAL-CHAT-BEST-PLAN-9-736
---

Hereâ€™s a JSON Schema you can use for each line of `docs_inventory.jsonl`.

Each line in `docs_inventory.jsonl` is a **single object** that matches this schema.

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://example.com/schemas/docs_inventory_entry.schema.json",
  "title": "DocsInventoryEntry",
  "description": "One inventory record for a single .md/.txt document in the repo.",
  "type": "object",
  "additionalProperties": false,

  "required": [
    "path",
    "ext",
    "size_bytes",
    "in_archive",
    "in_sandbox",
    "in_modules"
  ],

  "properties": {
    "path": {
      "type": "string",
      "description": "Repository-relative path to the document, using forward slashes.",
      "minLength": 1
    },

    "ext": {
      "type": "string",
      "description": "File extension of the document.",
      "enum": [".md", ".txt"]
    },

    "basename": {
      "type": "string",
      "description": "Final path component (filename with extension).",
      "minLength": 1
    },

    "size_bytes": {
      "type": "integer",
      "description": "Size of the file in bytes.",
      "minimum": 0
    },

    "mtime": {
      "type": "string",
      "description": "Last modified time from the filesystem.",
      "format": "date-time"
    },

    "git_last_commit_date": {
      "type": "string",
      "description": "Timestamp of the last git commit that touched this file, if available.",
      "format": "date-time"
    },

    "first_line": {
      "type": "string",
      "description": "First line of the file, trimmed. Often a title or heading."
    },

    "sample_excerpt": {
      "type": "string",
      "description": "Short excerpt from the file (e.g., first ~200 characters, lowercased) for classification heuristics."
    },

    "in_archive": {
      "type": "boolean",
      "description": "True if the path is under an archive/ directory."
    },

    "in_sandbox": {
      "type": "boolean",
      "description": "True if the path is under a sandbox/experimental directory (e.g. AI_SANDBOX/)."
    },

    "in_modules": {
      "type": "boolean",
      "description": "True if the path is currently under modules/."
    },

    "guess_module_from_path": {
      "type": "string",
      "description": "Heuristic guess of module name from path segments (e.g. 'aim', 'engine', 'error', 'openspec')."
    },

    "zone": {
      "type": "string",
      "description": "Coarse location/category for the document based on its path.",
      "enum": [
        "ARCHIVE",
        "SANDBOX",
        "GLOBAL",
        "MODULE_CANDIDATE",
        "MISC"
      ]
    },

    "doc_role": {
      "type": "string",
      "description": "Semantic role of the document content.",
      "enum": [
        "SPEC",
        "DESIGN",
        "PLAN",
        "REPORT",
        "ADR",
        "HOWTO",
        "GLOSSARY",
        "LOG_NOTE",
        "PROMPT_TEMPLATE",
        "UNKNOWN"
      ]
    },

    "module_id": {
      "type": "string",
      "description": "Canonical module identifier that should own this document (e.g. 'execution', 'aim_tools', 'patterns_engine', 'GLOBAL')."
    },

    "module_kind": {
      "type": "string",
      "description": "High-level kind of module this document belongs to.",
      "enum": [
        "PIPELINE_STAGE_MODULE",
        "FEATURE_SERVICE_MODULE",
        "INTEGRATION_BRIDGE_MODULE",
        "INTERFACE_MODULE",
        "REGISTRY_METADATA_MODULE",
        "INFRA_PLATFORM_MODULE",
        "OBSERVABILITY_REPORTING_MODULE",
        "GOVERNANCE_KNOWLEDGE_MODULE",
        "SANDBOX_EXPERIMENTAL_MODULE",
        "ARCHIVE_LEGACY_BUCKET"
      ]
    },

    "submodule_role": {
      "type": "string",
      "description": "Optional finer-grained role inside a module.",
      "enum": [
        "domain",
        "adapter",
        "utility",
        "cli",
        "doc",
        "schema",
        "test",
        "notes",
        "reports",
        "misc"
      ]
    },

    "artifact_id": {
      "type": "string",
      "description": "Stable ID for the document (e.g. doc_id ULID or other registry ID)."
    },

    "registry_status": {
      "type": "string",
      "description": "Registration status of this document in the central registry.",
      "enum": [
        "unregistered",
        "registered",
        "deprecated"
      ]
    },

    "tags": {
      "type": "array",
      "description": "Free-form tags to aid searching and grouping.",
      "items": {
        "type": "string",
        "minLength": 1
      },
      "uniqueItems": true
    },

    "notes": {
      "type": "string",
      "description": "Human or AI-generated notes about classification or migration decisions."
    }
  }
}
```

### How to use it with `docs_inventory.jsonl`

* `docs_inventory.jsonl` is a **JSON Lines** file.
* Each line is **one object** that should validate against `DocsInventoryEntry`.
* Example line:

```json
{"path":"docs/Why Module-Centric Works Better.txt","ext":".txt","basename":"Why Module-Centric Works Better.txt","size_bytes":12345,"mtime":"2025-11-26T03:12:45Z","git_last_commit_date":"2025-11-26T03:05:12Z","first_line":"# Why Module-Centric Works Better","sample_excerpt":"# why module-centric works better\n\nthis document explains...","in_archive":false,"in_sandbox":false,"in_modules":false,"guess_module_from_path":null,"zone":"GLOBAL","doc_role":"DESIGN","module_id":"GLOBAL","module_kind":"GOVERNANCE_KNOWLEDGE_MODULE","submodule_role":"doc","artifact_id":"01HXYZ123ABCDEF456","registry_status":"registered","tags":["architecture","module-centric"],"notes":"Top-level design doc; stays global."}
```

If you want, I can also give you a tiny Python script that:

* walks the repo,
* builds these objects,
* and writes `docs_inventory.jsonl` that conforms to this schema.
