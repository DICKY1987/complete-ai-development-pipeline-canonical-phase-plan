 ## PHASE PLAN

      ### Phase 0: Dependencies & Setup (30 minutes)

      **Goal**: Install missing dependencies and verify database exists

      **Execution Pattern**: Manual setup (one-time)

      **Actions**:

      1. **Add Textual to requirements**
         ```yaml
         # config/requirements.txt
         textual>=0.50.0
         textual-dev>=1.2.0  # Dev tools
         ```

      2. **Install dependencies**
         ```bash
         pip install -r config/requirements.txt
         ```

      3. **Verify database exists**
         ```bash
         ls .worktrees/pipeline_state.db
         sqlite3 .worktrees/pipeline_state.db ".tables"
         ```

      4. **Create launcher directory**
         ```bash
         mkdir -p tui_app/launcher
         ```

      **Validation**:
      - [x] `python -c "import textual"` succeeds
      - [x] Database file exists
      - [x] Database has expected tables

      **Time**: 30 minutes

      ---

      ### Phase 1: SQLite Backend Implementation (2 hours)

      **Goal**: Replace InMemoryStateBackend with real SQLite backend

      **Execution Pattern**: EXEC-002 (Module Generator) - Create
      backend class

      **Files to Create**:

      #### 1.1 `tui_app/core/sqlite_state_backend.py` (NEW)

      ```python
      """SQLite backend for state storage."""

      import sqlite3
      from pathlib import Path
      from typing import List, Optional
      from datetime import datetime

      from tui_app.core.state_client import (
          StateBackend,
          PipelineSummary,
          TaskInfo
      )


      class SQLiteStateBackend(StateBackend):
          """SQLite-based state backend."""

          def __init__(self, db_path: Optional[str] = None):
              self.db_path = db_path or
      str(Path(".worktrees/pipeline_state.db"))
              self._conn = None

          def _get_conn(self) -> sqlite3.Connection:
              if self._conn is None:
                  self._conn = sqlite3.connect(self.db_path)
                  self._conn.row_factory = sqlite3.Row
              return self._conn

          def get_pipeline_summary(self) -> PipelineSummary:
              conn = self._get_conn()
              cur = conn.cursor()

              # Get latest run
              cur.execute("""
                  SELECT * FROM runs
                  ORDER BY created_at DESC
                  LIMIT 1
              """)
              run = cur.fetchone()

              if not run:
                  return PipelineSummary(
                      total_tasks=0,
                      running_tasks=0,
                      completed_tasks=0,
                      failed_tasks=0,
                      active_workers=0,
                      last_update=datetime.now(),
                      status="idle"
                  )

              run_id = run["run_id"]

              # Count tasks by status
              cur.execute("""
                  SELECT status, COUNT(*) as count
                  FROM step_attempts
                  WHERE run_id = ?
                  GROUP BY status
              """, (run_id,))

              counts = {}
              for row in cur:
                  counts[row["status"]] = row["count"]

              return PipelineSummary(
                  total_tasks=sum(counts.values()),
                  running_tasks=counts.get("running", 0),
                  completed_tasks=counts.get("completed", 0),
                  failed_tasks=counts.get("failed", 0) +
      counts.get("timeout", 0),
                  active_workers=0,  # TODO: query workers table

      last_update=datetime.fromisoformat(run["created_at"].replace("Z",
      "")),
                  status=run["status"]
              )

          def get_tasks(self, limit: int = 100) -> List[TaskInfo]:
              conn = self._get_conn()
              cur = conn.cursor()

              # Get latest run
              cur.execute("SELECT run_id FROM runs ORDER BY created_at
      DESC LIMIT 1")
              run_row = cur.fetchone()
              if not run_row:
                  return []

              run_id = run_row["run_id"]

              # Get tasks for this run
              cur.execute("""
                  SELECT * FROM step_attempts
                  WHERE run_id = ?
                  ORDER BY started_at DESC
                  LIMIT ?
              """, (run_id, limit))

              tasks = []
              for row in cur:
                  start_time = None
                  end_time = None

                  if row["started_at"]:
                      start_time =
      datetime.fromisoformat(row["started_at"].replace("Z", ""))
                  if row["completed_at"]:
                      end_time =
      datetime.fromisoformat(row["completed_at"].replace("Z", ""))

                  tasks.append(TaskInfo(
                      task_id=str(row["id"]),
                      name=row["step_name"],
                      status=row["status"],
                      worker_id=row.get("worker_id"),
                      start_time=start_time,
                      end_time=end_time,
                      error_message=None  # TODO: extract from
      result_json
                  ))

              return tasks

          def get_task(self, task_id: str) -> Optional[TaskInfo]:
              conn = self._get_conn()
              cur = conn.cursor()

              cur.execute("SELECT * FROM step_attempts WHERE id = ?",
      (int(task_id),))
              row = cur.fetchone()

              if not row:
                  return None

              start_time = None
              end_time = None

              if row["started_at"]:
                  start_time =
      datetime.fromisoformat(row["started_at"].replace("Z", ""))
              if row["completed_at"]:
                  end_time =
      datetime.fromisoformat(row["completed_at"].replace("Z", ""))

              return TaskInfo(
                  task_id=str(row["id"]),
                  name=row["step_name"],
                  status=row["status"],
                  worker_id=row.get("worker_id"),
                  start_time=start_time,
                  end_time=end_time,
                  error_message=None
              )

          def close(self):
              if self._conn:
                  self._conn.close()
                  self._conn = None
      ```

      #### 1.2 Modify `tui_app/main.py`

      ```python
      # Change line 61-62 from:
      self.state_client = StateClient(InMemoryStateBackend())

      # To:
      from tui_app.core.sqlite_state_backend import SQLiteStateBackend
      self.state_client = StateClient(SQLiteStateBackend())
      ```

      **Testing**:
      ```bash
      # Update test to use SQLite backend
      python -m pytest tests/tui_panel_framework/test_state_client.py
   -v

      # Smoke test with real data
      python -m tui_app.main --smoke-test
      ```

      **Validation**:
      - [x] Dashboard shows real data from database
      - [x] No crashes on missing database
      - [x] Task counts match database records

      **Time**: 2 hours

      ---

      ### Phase 2: Implement Skeleton Panels (3 hours)

      **Goal**: Complete FileLifecyclePanel, ToolHealthPanel,
      LogStreamPanel

      **Execution Pattern**: EXEC-001 (Batch File Creator) - Use
      template for similar panels

      **Template Pattern** (from DashboardPanel):
      ```python
      @register_panel("panel_id")
      class PanelClass:
          @property
          def panel_id(self) -> str:
              return "panel_id"

          @property
          def title(self) -> str:
              return "Panel Title"

          def create_widget(self, context: PanelContext) -> Static:
              # Query backend for data
              data = context.state_client.get_XXXX()

              # Build display text
              lines = ["[bold cyan]Panel Title[/]", ""]
              for item in data:
                  lines.append(f"• {item.field}")

              return Static("\n".join(lines))

          def on_mount(self, context: PanelContext) -> None:
              pass

          def on_unmount(self, context: PanelContext) -> None:
              pass
      ```

      #### 2.1 FileLifecyclePanel Implementation

      **File**: `tui_app/panels/file_lifecycle_panel.py`

      **Data Source**: `file_lifecycle` table

      **Query**:
      ```sql
      SELECT * FROM file_lifecycle
      WHERE run_id = (SELECT run_id FROM runs ORDER BY created_at DESC
      LIMIT 1)
      ORDER BY timestamp DESC
      LIMIT 50
      ```

      **Backend Method** (add to SQLiteStateBackend):
      ```python
      def get_file_lifecycle(self, limit: int = 50) -> List[Dict]:
          conn = self._get_conn()
          cur = conn.cursor()

          # Get latest run
          cur.execute("SELECT run_id FROM runs ORDER BY created_at DESC
      LIMIT 1")
          run_row = cur.fetchone()
          if not run_row:
              return []

          run_id = run_row["run_id"]

          cur.execute("""
              SELECT * FROM file_lifecycle
              WHERE run_id = ?
              ORDER BY timestamp DESC
              LIMIT ?
          """, (run_id, limit))

          return [dict(row) for row in cur.fetchall()]
      ```

      **Panel Code**:
      ```python
      def create_widget(self, context: PanelContext) -> Static:
          if not hasattr(context.state_client._backend,
      'get_file_lifecycle'):
              return Static("[yellow]File lifecycle tracking not
      available[/]")

          files =
      context.state_client._backend.get_file_lifecycle(limit=20)

          if not files:
              return Static("[dim]No files tracked yet[/]")

          lines = [
              "[bold cyan]File Lifecycle Tracker[/]",
              "",
              f"Total Files: {len(files)}",
              "",
              "[bold]Recent Activity:[/]",
              ""
          ]

          for file in files[:10]:
              state = file.get("state", "unknown")
              path = file.get("file_path", "unknown")

              state_color = {
                  "discovered": "blue",
                  "processing": "yellow",
                  "completed": "green",
                  "quarantined": "red"
              }.get(state, "white")

              lines.append(f"[{state_color}]●[/] {path}")
              lines.append(f"  State: {state}")
              lines.append("")

          return Static("\n".join(lines))
      ```

      #### 2.2 ToolHealthPanel Implementation

      **Data Source**: `tool_health_metrics` table

      **Query**:
      ```sql
      SELECT * FROM tool_health_metrics
      ORDER BY timestamp DESC
      LIMIT 20
      ```

      **Backend Method**:
      ```python
      def get_tool_health(self, limit: int = 20) -> List[Dict]:
          conn = self._get_conn()
          cur = conn.cursor()

          cur.execute("""
              SELECT * FROM tool_health_metrics
              ORDER BY timestamp DESC
              LIMIT ?
          """, (limit,))

          return [dict(row) for row in cur.fetchall()]
      ```

      **Panel Code**:
      ```python
      def create_widget(self, context: PanelContext) -> Static:
          if not hasattr(context.state_client._backend,
      'get_tool_health'):
              return Static("[yellow]Tool health metrics not
      available[/]")

          metrics =
      context.state_client._backend.get_tool_health(limit=10)

          if not metrics:
              return Static("[dim]No tool health data yet[/]")

          lines = [
              "[bold cyan]Tool Health Monitor[/]",
              "",
              "[bold]Recent Metrics:[/]",
              ""
          ]

          # Group by tool
          tools = {}
          for metric in metrics:
              tool_name = metric.get("tool_name", "unknown")
              if tool_name not in tools:
                  tools[tool_name] = metric

          for tool_name, metric in tools.items():
              health = metric.get("health_status", "unknown")

              health_color = {
                  "healthy": "green",
                  "degraded": "yellow",
                  "error": "red"
              }.get(health, "white")

              lines.append(f"[{health_color}]●[/] {tool_name}")
              lines.append(f"  Status: {health}")
              lines.append(f"  Last Check: {metric.get('timestamp',
      'unknown')}")
              lines.append("")

          return Static("\n".join(lines))
      ```

      #### 2.3 LogStreamPanel Implementation

      **Data Source**: `events` table

      **Query**:
      ```sql
      SELECT * FROM events
      WHERE run_id = (SELECT run_id FROM runs ORDER BY created_at DESC
      LIMIT 1)
      ORDER BY timestamp DESC
      LIMIT 100
      ```

      **Backend Method**:
      ```python
      def get_recent_events(self, limit: int = 100) -> List[Dict]:
          conn = self._get_conn()
          cur = conn.cursor()

          # Get latest run
          cur.execute("SELECT run_id FROM runs ORDER BY created_at DESC
      LIMIT 1")
          run_row = cur.fetchone()
          if not run_row:
              return []

          run_id = run_row["run_id"]

          cur.execute("""
              SELECT * FROM events
              WHERE run_id = ?
              ORDER BY timestamp DESC
              LIMIT ?
          """, (run_id, limit))

          return [dict(row) for row in cur.fetchall()]
      ```

      **Panel Code**:
      ```python
      def create_widget(self, context: PanelContext) -> Static:
          if not hasattr(context.state_client._backend,
      'get_recent_events'):
              return Static("[yellow]Event log not available[/]")

          events =
      context.state_client._backend.get_recent_events(limit=30)

          if not events:
              return Static("[dim]No events logged yet[/]")

          lines = [
              "[bold cyan]Event Log Stream[/]",
              "",
              f"Total Events: {len(events)}",
              "",
              "[bold]Recent Events:[/]",
              ""
          ]

          for event in events[:20]:
              event_type = event.get("event_type", "unknown")
              timestamp = event.get("timestamp", "unknown")

              event_color = {
                  "started": "blue",
                  "completed": "green",
                  "failed": "red",
                  "warning": "yellow"
              }.get(event_type.split(".")[-1], "white")

              lines.append(f"[{event_color}]●[/] {timestamp}")
              lines.append(f"  {event_type}")
              lines.append("")

          return Static("\n".join(lines))
      ```

      **Testing**:
      ```bash
      # Test each panel individually
      python -m pytest tests/tui_panel_framework/test_panels_smoke.py
   -v

      # Manual smoke test
      python -m tui_app.main --panel file_lifecycle
      python -m tui_app.main --panel tool_health
      python -m tui_app.main --panel log_stream
      ```

      **Validation**:
      - [x] All panels render without errors
      - [x] Panels show real data from database
      - [x] Graceful handling of empty tables
      - [x] All 26 tests still pass

      **Time**: 3 hours

      ---

      ### Phase 3: Manual Refresh Implementation (1 hour)

      **Goal**: Add 'r' key binding to reload data from database

      **Files to Modify**:

      #### 3.1 `tui_app/main.py`

      **Add key binding**:
      ```python
      BINDINGS = [
          ("q", "quit", "Quit"),
          ("r", "refresh_data", "Refresh"),  # NEW
          ("d", "switch_dashboard", "Dashboard"),
          # ... rest
      ]
      ```

      **Add action handler**:
      ```python
      def action_refresh_data(self) -> None:
          """Refresh data from backend and re-render current panel."""
          # Get current panel
          container = self.query_one("#panel-container", Container)
          if not container.children:
              return

          # Re-mount current panel (forces data reload)
          current_panel_id = self.panel_id
          self._mount_panel(current_panel_id)

          # Show notification
          self.notify("Data refreshed", severity="information")
      ```

      **Validation**:
      ```bash
      # Manual test
      python -m tui_app.main
      # Press 'r' key - should see "Data refreshed" notification
      # Verify panel reloads
      ```

      **Time**: 1 hour

      ---

      ### Phase 4: Desktop Launcher Scripts (2 hours)

      **Goal**: Create Windows shortcuts and launchers

      **Files to Create**:

      #### 4.1 `tui_app/launcher/launch_tui.bat` (NEW)

      ```batch
      @echo off
      REM Desktop launcher for AI Pipeline TUI
      REM Auto-generated - do not edit manually

      SETLOCAL

      REM Get script directory
      SET SCRIPT_DIR=%~dp0
      cd /d "%SCRIPT_DIR%\..\.."

      REM Activate virtual environment if exists
      IF EXIST venv\Scripts\activate.bat (
          CALL venv\Scripts\activate.bat
      )

      REM Launch TUI
      python -m tui_app.main

      REM Pause on exit (so user sees errors)
      PAUSE

      ENDLOCAL
      ```

      #### 4.2 `tui_app/launcher/create_shortcut.ps1` (NEW)

      ```powershell
      # PowerShell script to create desktop shortcut
      # Usage: .\create_shortcut.ps1

      $ProjectRoot = Split-Path -Parent (Split-Path -Parent
      $PSScriptRoot)
      $LauncherPath = Join-Path $ProjectRoot
      "tui_app\launcher\launch_tui.bat"
      $IconPath = Join-Path $ProjectRoot "tui_app\launcher\icon.ico"
      $ShortcutPath = Join-Path $env:USERPROFILE "Desktop\AI Pipeline
      Monitor.lnk"

      # Create shortcut
      $WshShell = New-Object -ComObject WScript.Shell
      $Shortcut = $WshShell.CreateShortcut($ShortcutPath)
      $Shortcut.TargetPath = $LauncherPath
      $Shortcut.WorkingDirectory = $ProjectRoot
      $Shortcut.Description = "AI Development Pipeline Monitor (TUI)"

      # Set icon if exists
      if (Test-Path $IconPath) {
          $Shortcut.IconLocation = $IconPath
      }

      $Shortcut.Save()

      Write-Host "✓ Desktop shortcut created: $ShortcutPath"
      -ForegroundColor Green
      ```

      #### 4.3 `tui_app/launcher/install_start_menu.ps1` (NEW)

      ```powershell
      # Install to Windows Start Menu
      # Requires admin privileges

      $ProjectRoot = Split-Path -Parent (Split-Path -Parent
      $PSScriptRoot)
      $LauncherPath = Join-Path $ProjectRoot
      "tui_app\launcher\launch_tui.bat"
      $IconPath = Join-Path $ProjectRoot "tui_app\launcher\icon.ico"

      # Start Menu path
      $StartMenuPath = Join-Path $env:APPDATA "Microsoft\Windows\Start
      Menu\Programs"
      $ShortcutPath = Join-Path $StartMenuPath "AI Pipeline
   Monitor.lnk"

      # Create shortcut
      $WshShell = New-Object -ComObject WScript.Shell
      $Shortcut = $WshShell.CreateShortcut($ShortcutPath)
      $Shortcut.TargetPath = $LauncherPath
      $Shortcut.WorkingDirectory = $ProjectRoot
      $Shortcut.Description = "AI Development Pipeline Monitor (TUI)"

      if (Test-Path $IconPath) {
          $Shortcut.IconLocation = $IconPath
      }

      $Shortcut.Save()

      Write-Host "✓ Start Menu shortcut created: $ShortcutPath"
      -ForegroundColor Green
      Write-Host "  Search 'AI Pipeline Monitor' in Start Menu"
      -ForegroundColor Cyan
      ```

      #### 4.4 `tui_app/launcher/icon.ico` (OPTIONAL)

      Create a simple icon or use existing Python icon. Can be
   generated
       later.

      #### 4.5 `tui_app/launcher/README.md` (NEW)

      ```markdown
      # TUI Launcher Scripts

      Desktop integration for AI Pipeline TUI.

      ## Quick Start

      ### Create Desktop Shortcut
      ```powershell
      .\create_shortcut.ps1
      ```

      ### Install to Start Menu
      ```powershell
      .\install_start_menu.ps1
      ```

      ### Manual Launch
      ```batch
      .\launch_tui.bat
      ```

      ## Files

      - `launch_tui.bat` - Windows batch launcher
      - `create_shortcut.ps1` - Desktop shortcut creator
      - `install_start_menu.ps1` - Start Menu installer
      - `icon.ico` - Application icon (optional)

      ## Requirements

      - Python 3.12+
      - Textual installed (`pip install textual`)
      - Project root accessible

      ## Troubleshooting

      **"python not found"**
      - Ensure Python is in PATH
      - Activate virtual environment first

      **"Module not found: tui_app"**
      - Ensure launcher runs from project root
      - Check WorkingDirectory in shortcut

      **Shortcut doesn't work**
      - Right-click → Properties → Check paths
      - Verify launcher.bat exists
      - Test launcher.bat directly first
      ```

      **Testing**:
      ```powershell
      # 1. Test batch launcher
      cd tui_app\launcher
      .\launch_tui.bat

      # 2. Create desktop shortcut
      .\create_shortcut.ps1

      # 3. Test shortcut (double-click from desktop)

      # 4. Install to Start Menu
      .\install_start_menu.ps1

      # 5. Test Start Menu entry
      # Press Win key, type "AI Pipeline Monitor"
      ```

      **Validation**:
      - [x] Desktop shortcut launches TUI
      - [x] Start Menu entry works
      - [x] Launcher handles missing database gracefully
      - [x] Window stays open after TUI exits

      **Time**: 2 hours

      ---

      ### Phase 5: Testing & Documentation (1.5 hours)

      **Goal**: Comprehensive testing and user documentation

      #### 5.1 Update Tests

      **File**: `tests/tui_panel_framework/test_sqlite_backend.py`
   (NEW)

      ```python
      """Tests for SQLite backend."""

      import pytest
      import tempfile
      import sqlite3
      from pathlib import Path

      from tui_app.core.sqlite_state_backend import SQLiteStateBackend


      @pytest.fixture
      def temp_db():
          """Create temporary database with test data."""
          fd, path = tempfile.mkstemp(suffix=".db")
          conn = sqlite3.connect(path)

          # Create minimal schema
          conn.execute("""
              CREATE TABLE runs (
                  run_id TEXT PRIMARY KEY,
                  status TEXT,
                  created_at TEXT
              )
          """)

          conn.execute("""
              CREATE TABLE step_attempts (
                  id INTEGER PRIMARY KEY,
                  run_id TEXT,
                  step_name TEXT,
                  status TEXT,
                  started_at TEXT,
                  completed_at TEXT
              )
          """)

          # Insert test data
          conn.execute("""
              INSERT INTO runs VALUES ('run-001', 'completed',
      '2025-11-27T10:00:00Z')
          """)

          conn.execute("""
              INSERT INTO step_attempts VALUES
              (1, 'run-001', 'Test Task', 'completed',
      '2025-11-27T10:00:00Z', '2025-11-27T10:05:00Z')
          """)

          conn.commit()
          conn.close()

          yield path

          Path(path).unlink()


      def test_sqlite_backend_get_pipeline_summary(temp_db):
          backend = SQLiteStateBackend(temp_db)
          summary = backend.get_pipeline_summary()

          assert summary.status == "completed"
          assert summary.total_tasks >= 1

          backend.close()


      def test_sqlite_backend_get_tasks(temp_db):
          backend = SQLiteStateBackend(temp_db)
          tasks = backend.get_tasks(limit=10)

          assert len(tasks) >= 1
          assert tasks[0].name == "Test Task"
          assert tasks[0].status == "completed"

          backend.close()


      def test_sqlite_backend_handles_missing_db():
          backend = SQLiteStateBackend("/nonexistent/path.db")

          # Should not crash, should return empty data
          summary = backend.get_pipeline_summary()
          assert summary.total_tasks == 0
      ```

      **Run all tests**:
      ```bash
      python -m pytest tests/tui_panel_framework/ -v
      # Should show 29+ tests passing (26 existing + 3 new)
      ```

      #### 5.2 Create User Documentation

      **File**: `tui_app/README.md` (UPDATE)

      ```markdown
      # AI Pipeline TUI - Terminal User Interface

      Real-time monitoring and control for the AI Development Pipeline.

      ## Features

      - **5 Monitoring Panels**
        - Dashboard: Pipeline summary and recent tasks
        - File Lifecycle: Track files through detection → patching →
      validation
        - Tool Health: Monitor error detection tool status
        - Log Stream: Real-time event log
        - Pattern Activity: Track pattern execution runs

      - **Manual Refresh**: Press 'r' to reload data from database
      - **Desktop Launch**: Windows shortcut for easy access
      - **SQLite Backend**: Reads live data from pipeline database

      ## Quick Start

      ### Desktop Shortcut (Easiest)

      1. Create desktop shortcut:
         ```powershell
         cd tui_app\launcher
         .\create_shortcut.ps1
         ```

      2. Double-click "AI Pipeline Monitor" on desktop

      ### Command Line

      ```bash
      # Launch TUI
      python -m tui_app.main

      # Launch specific panel
      python -m tui_app.main --panel dashboard
      python -m tui_app.main --panel file_lifecycle
      python -m tui_app.main --panel tool_health
      python -m tui_app.main --panel log_stream
      python -m tui_app.main --panel pattern_activity
      ```

      ## Keyboard Shortcuts

      | Key | Action |
      |-----|--------|
      | `q` | Quit TUI |
      | `r` | Refresh data from database |
      | `d` | Switch to Dashboard panel |
      | `f` | Switch to File Lifecycle panel |
      | `t` | Switch to Tool Health panel |
      | `l` | Switch to Log Stream panel |
      | `p` | Switch to Pattern Activity panel |

      ## Requirements

      - Python 3.12+
      - Textual >= 0.50.0
      - SQLite database at `.worktrees/pipeline_state.db`

      ## Installation

      ```bash
      # Install dependencies
      pip install -r config/requirements.txt

      # Verify installation
      python -m tui_app.main --smoke-test
      ```

      ## Architecture

      ### Panel System

      ```
      tui_app/
       main.py                    # Application entry point
       core/
          panel_plugin.py        # Panel plugin interface
          panel_registry.py      # Panel registration
          state_client.py        # Data client interface
          sqlite_state_backend.py # SQLite backend
          layout_manager.py      # Panel layout manager
       panels/
           dashboard_panel.py     # Dashboard implementation
           file_lifecycle_panel.py
           tool_health_panel.py
           log_stream_panel.py
           pattern_activity_panel.py
      ```

      ### Data Flow

      ```
      [TUI Panels] → [StateClient] → [SQLiteBackend] →
      [pipeline_state.db]
           ↑              ↑                ↑
           |              |                |
        Textual       Pluggable        Direct SQL
        Widgets       Backend         Queries
      ```

      ## Development

      ### Run Tests

      ```bash
      python -m pytest tests/tui_panel_framework/ -v
      ```

      ### Add New Panel

      1. Create panel class in `tui_app/panels/`
      2. Use `@register_panel("panel_id")` decorator
      3. Implement required methods:
         - `panel_id` property
         - `title` property
         - `create_widget(context)` method
      4. Add test in `tests/tui_panel_framework/`

      ## Troubleshooting

      ### "No module named 'textual'"
      ```bash
      pip install textual>=0.50.0
      ```

      ### "Database not found"
      - Ensure pipeline has run at least once
      - Check `.worktrees/pipeline_state.db` exists
      - TUI will show "No data available" if database is empty

      ### Desktop shortcut doesn't work
      - Right-click shortcut → Properties
      - Verify "Target" points to `launch_tui.bat`
      - Verify "Start in" points to project root
      - Test `launch_tui.bat` directly first

      ## License

      Part of the AI Development Pipeline project.
      ```

      **Time**: 1.5 hours

      ---

      ### Phase 6: Packaging & Installer (Optional, 2 hours)

      **Goal**: Create installable package for distribution

      **Note**: This phase is optional for initial delivery. Can be
      completed later.

      #### 6.1 PyInstaller Bundle (OPTIONAL)

      Create standalone executable that bundles Python + dependencies.

      ```bash
      pip install pyinstaller

      pyinstaller --onefile \
          --name "AI_Pipeline_Monitor" \
          --icon tui_app/launcher/icon.ico \
          --add-data "tui_app:tui_app" \
          tui_app/main.py
      ```

      #### 6.2 Inno Setup Installer (OPTIONAL)

      Create Windows installer with:
      - Install to Program Files
      - Add to Start Menu
      - Desktop shortcut option
      - Uninstaller

      **Time**: 2 hours (optional)

      ---

      ## GAPS ANALYSIS

      ### Current vs Target State

      | Component | Current | Target | Gap |
      |-----------|---------|--------|-----|
      | **TUI Framework** | ✅ Complete | 5 panels | ✅ Done |
      | **Textual Dependency** | ❌ Missing | In requirements.txt |
      Phase 0 |
      | **SQLite Backend** | ❌ Mock data | Real database | Phase 1 |
      | **Dashboard Panel** | ✅ Working | Show real data | Phase 1 |
      | **File Lifecycle Panel** | ❌ Skeleton | Query file_lifecycle |
      Phase 2 |
      | **Tool Health Panel** | ❌ Skeleton | Query tool_health_metrics
      | Phase 2 |
      | **Log Stream Panel** | ❌ Skeleton | Query events table | Phase
      2 |
      | **Pattern Activity Panel** | ✅ Working | Show real data |
   Phase
       1 |
      | **Manual Refresh** | ❌ Missing | 'r' key binding | Phase 3 |
      | **Desktop Shortcut** | ❌ Missing | Windows .lnk | Phase 4 |
      | **Start Menu Entry** | ❌ Missing | Install script | Phase 4 |
      | **Batch Launcher** | ❌ Missing | launch_tui.bat | Phase 4 |
      | **Documentation** | ⚠️ Minimal | Complete README | Phase 5 |
      | **Tests** | ✅ 26 passing | 29+ passing | Phase 5 |
      | **Installer** | ❌ None | Optional | Phase 6 |

      ### Critical Dependencies

      **Before Starting**:
      - ✅ Existing TUI framework (tui_app/)
      - ✅ Database exists (.worktrees/pipeline_state.db)
      - ✅ Schema has required tables
      - ❌ Textual dependency installed → **Phase 0**

      **Between Phases**:
      - Phase 1 → Phase 2: SQLite backend must work
      - Phase 2 → Phase 3: Panels must render
      - Phase 3 → Phase 4: Refresh must work
      - Phase 4 → Phase 5: Launchers must work

      ---

      ## IMPLEMENTATION SEQUENCE

      ### Day 1 (Morning): Foundation
      - Phase 0: Dependencies (30 min)
      - Phase 1: SQLite Backend (2 hours)
      - **Checkpoint**: Dashboard shows real data

      ### Day 1 (Afternoon): Panels
      - Phase 2: Implement 3 skeleton panels (3 hours)
      - **Checkpoint**: All 5 panels functional

      ### Day 2 (Morning): Polish
      - Phase 3: Manual refresh (1 hour)
      - Phase 4: Desktop launchers (2 hours)
      - **Checkpoint**: Desktop shortcut works

      ### Day 2 (Afternoon): Quality
      - Phase 5: Testing & docs (1.5 hours)
      - **Checkpoint**: All tests pass, README complete

      ### Day 3 (Optional): Distribution
      - Phase 6: Packaging & installer (2 hours)
      - **Checkpoint**: Installable package ready

      **Total Time**: 10 hours (2-3 days)
      **Optional Packaging**: +2 hours

      ---

      ## SUCCESS CRITERIA

      A task is complete when ALL of these are true:

      ### Phase 0: Dependencies
      - [x] `pip show textual` shows version >= 0.50.0
      - [x] Database file exists at `.worktrees/pipeline_state.db`
      - [x] `python -m tui_app.main --smoke-test` exits 0

      ### Phase 1: SQLite Backend
      - [x] `SQLiteStateBackend` class exists
      - [x] Dashboard shows real task counts from database
      - [x] No crashes on empty database
      - [x] All existing tests still pass

      ### Phase 2: Skeleton Panels
      - [x] FileLifecyclePanel queries `file_lifecycle` table
      - [x] ToolHealthPanel queries `tool_health_metrics` table
      - [x] LogStreamPanel queries `events` table
      - [x] All panels render without errors
      - [x] 26+ tests passing

      ### Phase 3: Manual Refresh
      - [x] 'r' key reloads panel data
      - [x] Notification shows "Data refreshed"
      - [x] Panel content updates after refresh

      ### Phase 4: Desktop Launcher
      - [x] `launch_tui.bat` starts TUI
      - [x] Desktop shortcut launches TUI
      - [x] Start Menu entry works
      - [x] Window stays open after exit (PAUSE)

      ### Phase 5: Testing & Docs
      - [x] 29+ tests passing (26 old + 3 new)
      - [x] README.md complete with usage examples
      - [x] All keyboard shortcuts documented

      ### Phase 6: Packaging (Optional)
      - [x] PyInstaller bundle works
      - [x] Installer creates shortcuts
      - [x] Uninstaller removes all files

      ---

      ## EXECUTION PATTERNS USED

      ### EXEC-001: Batch File Creator
      **Used in**: Phase 2 (Skeleton Panels)

      **Savings**: 3 panels × 1 hour = 3 hours → 1.5 hours (50%
   savings)

      **Template**:
      ```python
      # panel_template.py
      @register_panel("{panel_id}")
      class {PanelClass}:
          @property
          def panel_id(self) -> str:
              return "{panel_id}"

          @property
          def title(self) -> str:
              return "{Panel Title}"

          def create_widget(self, context: PanelContext) -> Static:
              data = context.state_client._backend.get_{data_method}()
              # ... render logic
      ```

      **Items**:
      ```json
      [
        {"panel_id": "file_lifecycle", "PanelClass":
      "FileLifecyclePanel", "data_method": "file_lifecycle"},
        {"panel_id": "tool_health", "PanelClass": "ToolHealthPanel",
      "data_method": "tool_health"},
        {"panel_id": "log_stream", "PanelClass": "LogStreamPanel",
      "data_method": "recent_events"}
      ]
      ```

      ### EXEC-002: Module Generator
      **Used in**: Phase 1 (SQLite Backend), Phase 4 (Launchers)

      **Savings**: Standard module creation pattern eliminates
   decisions

      ---

      ## ANTI-PATTERNS TO AVOID

      ### 1. ❌ Polling in Background Thread
      **Why**: Adds complexity, threading bugs, resource overhead
      **Instead**: Manual refresh (simple, user-controlled)

      ### 2. ❌ Direct Database Access from Panels
      **Why**: Tight coupling, hard to test, no abstraction
      **Instead**: StateClient + Backend pattern (clean separation)

      ### 3. ❌ Hardcoded Paths
      **Why**: Breaks on different machines
      **Instead**: Relative paths, environment variables, config

      ### 4. ❌ No Error Handling on Missing DB
      **Why**: TUI crashes if database not found
      **Instead**: Graceful fallback, show "No data" message

      ### 5. ❌ Blocking I/O on Main Thread
      **Why**: TUI freezes during database queries
      **Instead**: Textual's async methods (not needed for manual
      refresh)

      ---

      ## RISK MITIGATION

      | Risk | Probability | Impact | Mitigation |
      |------|-------------|--------|------------|
      | Textual API changes | Low | High | Pin version in
      requirements.txt |
      | Database schema mismatch | Medium | High | Defensive SQL
      queries, handle missing columns |
      | Windows-specific launcher bugs | Medium | Medium | Test on
      multiple Windows versions |
      | Empty database crashes TUI | High | Medium | Return empty
   lists,
       show "No data" |
      | Path issues in shortcuts | High | Low | Use absolute paths,
   test
       WorkingDirectory |

      ---

      ## TESTING STRATEGY

      ### Unit Tests (Automated)
      ```bash
      # State backend
      pytest tests/tui_panel_framework/test_sqlite_backend.py -v

      # Panel smoke tests
      pytest tests/tui_panel_framework/test_panels_smoke.py -v

      # All TUI tests
      pytest tests/tui_panel_framework/ -v
      ```

      ### Integration Tests (Manual)
      ```bash
      # 1. Launch with empty database
      rm .worktrees/pipeline_state.db
      python -m tui_app.main
      # Expected: Shows "No data available"

      # 2. Launch with real database
      python -m tui_app.main
      # Expected: Shows actual data

      # 3. Test all panels
      for panel in dashboard file_lifecycle tool_health log_stream
      pattern_activity; do
          python -m tui_app.main --panel $panel
      done

      # 4. Test refresh
      python -m tui_app.main
      # Press 'r' key
      # Expected: "Data refreshed" notification

      # 5. Test desktop shortcut
      .\create_shortcut.ps1
      # Double-click shortcut
      # Expected: TUI launches
      ```

      ### Smoke Tests (Quick Validation)
      ```bash
      # 10-second smoke test
      python -m tui_app.main --smoke-test
      echo $?  # Should be 0
      ```

      ---

      ## DEPLOYMENT CHECKLIST

      ### Pre-Deployment
      - [x] All tests pass (`pytest tests/tui_panel_framework/`)
      - [x] Smoke test passes (`python -m tui_app.main --smoke-test`)
      - [x] Database exists and has schema
      - [x] README.md complete

      ### Installation Steps
      1. Install dependencies: `pip install -r config/requirements.txt`
      2. Verify database: `ls .worktrees/pipeline_state.db`
      3. Test TUI: `python -m tui_app.main --smoke-test`
      4. Create shortcut: `.\tui_app\launcher\create_shortcut.ps1`
      5. Test shortcut: Double-click desktop icon

      ### Verification
      ```bash
      # 1. Launch TUI
      python -m tui_app.main

      # 2. Check all panels
      # Press: d, f, t, l, p (cycle through panels)

      # 3. Test refresh
      # Press: r (should see notification)

      # 4. Quit
      # Press: q
      ```

      ---

      ## FUTURE ENHANCEMENTS (Out of Scope)

      The following features are explicitly **not included** in this
      phase plan but may be considered for future iterations:

      1. **Auto-refresh with configurable interval** (Phase 7)
      2. **System tray integration** (Phase 8)
      3. **WebSocket real-time updates** (Phase 9)
      4. **Multi-run comparison** (Phase 10)
      5. **Export to CSV/JSON** (Phase 11)
      6. **Interactive filtering/search** (Phase 12)
      7. **Panel customization (drag/drop)** (Phase 13)

      ---

      PLAN_EOF
      echo "Plan created"
      Create comprehensive phase plan
