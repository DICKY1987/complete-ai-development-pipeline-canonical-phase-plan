TITLE: PH-03.5 – Aider Integration Contract & Prompt Template System (Codex Autonomous Phase Executor)

ROLE
You are Codex running with full access to a Windows development environment using PowerShell and Git.
Your job is to COMPLETELY IMPLEMENT phase PH-03.5 (Aider Integration Contract & Prompt Template System) for the AI Development Pipeline project, end-to-end, without requiring further user input.

You will:
- Define a precise, written integration contract for the Aider CLI.
- Implement a prompt engine (prompts.py + Jinja templates) for EDIT and FIX steps.
- Wire Aider through the existing tools adapter (run_tool from tools.py).
- Add sandbox repos and integration tests to validate Aider behavior.
- Make this whole layer safe, reproducible, and easy for other phases to call.

OPERATING CONTEXT
- OS: Windows 10/11
- Shell: PowerShell 7+ (pwsh)
- Version control: git
- Orchestrator language: Python 3.12+
- Previous phases:
  - PH-00: project skeleton, docs, CI.
  - PH-01: spec index & canonical module layout.
  - PH-02: SQLite DB + state machine (db.py).
  - PH-03: Tool profiles & adapter layer (tool_profiles.json, tools.py with run_tool()).

PROJECT ROOT (IMPORTANT)
- Expected project root: C:\Users\richg\ALL_AI\AI_Dev_Pipeline

If that folder does NOT exist:
- Stop and write a clear, prominent note into docs/PHASE_PLAN.md under PH-03.5 that PH-00–PH-03 must be completed first.
- Do NOT attempt to install or configure Aider elsewhere.

If it DOES exist:
- cd into that folder and proceed.

====================================
HIGH-LEVEL GOAL OF PH-03.5
====================================

Create a robust, documented integration between the pipeline and Aider where:

1) There is a written, versioned **Aider integration contract** (doc) that other agents/humans can read.
2) There is a reusable **prompt engine** (prompts.py + templates) that can:
   - Build EDIT prompts for implementing workstreams.
   - Build FIX prompts using error lists and context.
3) Aider is invoked via the existing tool adapter (run_tool()) with a dedicated profile.
4) Safety rules are enforced:
   - Aider works in a dedicated worktree.
   - Aider does not auto-commit.
   - Edits are restricted to a known file scope.
5) Integration tests validate that Aider behaves correctly on small sandbox repos.

You are NOT building the overall EDIT/FIX orchestration loop here (that’s PH-05/PH-06). You are building the **reusable building blocks** that those phases will use.

====================================
REQUIRED OUTPUTS OF THIS PHASE
====================================

By the end of PH-03.5, the repo MUST have at minimum:

1) AIDER INTEGRATION CONTRACT DOC
- docs/aider_contract.md
  - This must explain, in detail:

    1) Aider binary & version assumptions
       - How we expect Aider to be installed (e.g., on PATH as `aider`).
       - Required minimal version (you may pick a placeholder like “>= 0.X, to be validated later” and document it).
       - How to check the version (command and expected output shape).

    2) CLI invocation pattern
       - The canonical command structure we will use, e.g.:
         - `aider --no-auto-commits --model <MODEL> <other-flags> <file-list>`
       - Which flags we always pass (e.g., `--no-auto-commits`, `--yes`).
       - Which flags are configurable (e.g., model name, max tokens, temperature).

    3) Environment variables
       - Required:
         - API keys for the model provider (OpenAI/Anthropic/etc.).
         - Config to disable auto-commits:
           - e.g. `AIDER_NO_AUTO_COMMITS=1` (if applicable).
       - Optional:
         - Proxy settings or base URL if needed.

    4) Working directory & git expectations
       - Aider will always run from inside a **worktree** dedicated to a single workstream.
       - The repo must be clean except for changes Aider will make during the step.
       - Aider must not implicitly commit or push.
       - There must be a tracked `.git` directory reachable from the working directory.

    5) I/O & behavior expectations
       - Aider will:
         - Read existing files from the worktree.
         - Modify only files it is given or allowed to create.
       - It may propose commits, but we do NOT let it commit automatically.

    6) Error handling
       - How we treat:
         - Non-zero exit codes from the Aider process.
         - Timeouts.
         - Partial output.
       - Mapping of common Aider failure patterns to error codes/signatures for db.errors.

    7) Contract versioning
       - A `CONTRACT_VERSION` string documented in this file (e.g., “AIDER_CONTRACT_V1”).
       - Later phases can refer to this contract version when running or testing.

2) AIDER TOOL PROFILE
- Update config/tool_profiles.json to include a dedicated Aider entry, e.g.:

  - "aider":
    - "type": "ai"
    - "command": "aider"  // assumes Aider is on PATH
    - "args": [
        "--no-auto-commits",
        "--yes",
        "--model", "{model_name}",
        "--message-file", "{prompt_file}"
      ]
    - "env": {
        "AIDER_NO_AUTO_COMMITS": "1"
        // optionally add placeholders for API keys (they should still come from your secrets system)
      }
    - "working_dir": "{worktree_path}"
    - "timeout_sec": 1800
    - "success_exit_codes": [0]
    - "capture_output": true

- Document any placeholders used:
  - {model_name}, {prompt_file}, {worktree_path} will be provided via context when calling run_tool("aider", ...).

3) PROMPT ENGINE MODULE
- Implement src/pipeline/prompts.py with the following responsibilities:

  - Take structured inputs:
    - run_id
    - ws_id
    - workstream bundle data (files_scope, files_create, tasks, acceptance_tests, openspec_change, gate, etc.)
    - error list (for FIX prompts)
    - context (e.g., repository root, worktree path)
  - Produce prompt text strings that will be written to prompt files and passed to Aider.

- Public functions to implement:

  1) build_edit_prompt(run_info, ws_info, bundle, context) -> str
     - Creates the full prompt for the EDIT step.
     - Prompt must:
       - Explain the pipeline’s context briefly.
       - Provide OpenSpec/CCPM identifiers (if available).
       - Describe the tasks / acceptance criteria.
       - List target files (files_scope, files_create).
       - Give clear instructions about constraints:
         - Only edit touch-listed files.
         - Maintain tests or add tests that pass.
         - Avoid refactoring outside scope unless necessary.

  2) build_fix_prompt(run_info, ws_info, bundle, errors, context) -> str
     - Creates the full prompt for the FIX step.
     - Prompt must:
       - Summarize what failed (static check errors, runtime test failures).
       - Provide relevant snippets of error messages.
       - Emphasize that the goal is to fix the failure WITHOUT breaking previously passing behavior.
       - Re-include file scope and constraints.

  3) (Optional) build_summary_prompt(...) or build_context_snippet(...)
     - If helpful for future phases, but not required.

- Implementation style:
  - Use Jinja2 templates or a simple string template mechanism.
  - Keep template text in separate files under templates/, not hardcoded strings where possible (see next section).

4) PROMPT TEMPLATES ON DISK
- Directory: templates/prompts/
  - templates/prompts/edit_prompt.txt.j2
  - templates/prompts/fix_prompt.txt.j2

- Each template should:
  - Accept placeholders for:
    - run_id, ws_id.
    - openspec_change, gate, ccpm_issue (if present).
    - tasks, acceptance_tests.
    - files_scope, files_create.
    - current branch/worktree info.
    - for FIX: error summaries.

  - Be written in a way that is:
    - Deterministic.
    - Easy for other AI agents to edit later (no giant monolithic paragraph).

- prompts.py should:
  - Load the appropriate template.
  - Render it with a context dict.
  - Return the final prompt text as str.

5) AIDER INVOCATION HELPERS
- A thin helper layer that builds on run_tool("aider", ...) from tools.py:

  - In src/pipeline/prompts.py or a new module src/pipeline/aider_integration.py, implement:

    - prepare_aider_prompt_file(prompt_text, worktree_path, ws_id, step_name) -> prompt_file_path
      - Writes the prompt text to a file under:
        - <worktree_path>/.aider/prompts/<ws_id>_<step_name>_<timestamp>.txt
      - Ensures directories exist.
      - Returns the absolute path.

    - run_aider_edit(run_info, ws_info, bundle, context, *, run_id=None, ws_id=None) -> ToolResult
      - Calls build_edit_prompt(...)
      - Writes prompt file via prepare_aider_prompt_file(...)
      - Calls run_tool("aider", context_with_prompt_file_and_model, run_id, ws_id)
      - Returns ToolResult.

    - run_aider_fix(run_info, ws_info, bundle, errors, context, *, run_id=None, ws_id=None) -> ToolResult
      - Same logic but uses build_fix_prompt(...).

- These helpers MUST:
  - Respect the Aider contract (docs/aider_contract.md).
  - Enforce working directory = worktree.
  - Only pass the allowed file list (or rely on PH-04.5 worktree scope enforcement after Aider runs).

6) SANDBOX REPOS & INTEGRATION TESTS
- Create a sandbox folder for end-to-end testing of Aider integration:

  - sandbox_repos/
    - sandbox_python/
      - A small Python project with:
        - 1–3 .py files.
        - A simple failing test or TODO to fix.
    - sandbox_powershell/ (optional)
      - A small PowerShell script + Pester test.

- Integration tests:
  - tests/integration/test_aider_sandbox.py
    - Mark with pytest markers e.g. @pytest.mark.slow or @pytest.mark.aider if desired.

  - Tests should:
    - Ensure Aider is available (e.g., by checking `shutil.which("aider")` or invoking `aider --version`).
      - If not available, skip tests with a clear message.
    - Create or use an existing worktree for each sandbox repo (you may rely on a simple clone/worktree pattern until PH-04.5 exists; document this assumption).
    - Build EDIT prompt and call run_aider_edit(...):
      - Confirm Aider exits with success (0), or if not fully possible now, at least ensure the invocation path works without crashing.
    - Build FIX prompt and call run_aider_fix(...):
      - Example scenario:
        - Introduce a simple failing test or linter issue and verify that run_aider_fix runs without error, even if it doesn’t fully heal the repo yet.

  - Tests should also:
    - Assert that prompt files are created under .aider/prompts.
    - Assert that db.events entries exist for Aider runs when run_id/ws_id are passed in.

7) DOCUMENTATION UPDATES
- docs/ARCHITECTURE.md:
  - Add or extend a section “Aider Integration & Prompt Engine”.
  - Explain:
    - Role of Aider in EDIT/FIX.
    - The existence of docs/aider_contract.md.
    - The location and role of templates/prompts/*.txt.j2.
    - How run_aider_edit / run_aider_fix will be used by future pipeline phases.

- docs/PHASE_PLAN.md:
  - Flesh out PH-03.5 section with:
    - Summary of Aider contract & prompt engine.
    - List of artifacts (aider_contract.md, prompts.py, templates, sandbox/tests).
    - A note that PH-05/PH-06 will call these helpers as part of the workstream pipeline.

8) GIT COMMIT
- Stage all new/modified files.
- Commit with message:
  - "PH-03.5: Aider integration contract and prompt template system"
- Do NOT push (remote configuration is out of scope).

====================================
CONSTRAINTS & PRINCIPLES
====================================

- Do NOT break or remove outputs from PH-00–PH-03; only extend them.
- Do NOT hardcode API keys or secrets in any config or code.
  - Use environment variables or a separate secrets system (already part of your broader stack).
- Keep prompts deterministic and explicit:
  - Avoid references like “just use your best judgment”; be concrete about file scope and goals.
- Keep sandbox tests safe:
  - Work only in sandbox_repos/, not in real projects.
  - Use ephemeral branches/worktrees.

====================================
EXECUTION PLAN (WHAT YOU SHOULD DO)
====================================

You should:

1) PRECHECKS & NAVIGATION
   - Confirm C:\Users\richg\ALL_AI\AI_Dev_Pipeline exists.
   - cd C:\Users\richg\ALL_AI\AI_Dev_Pipeline
   - Confirm src/pipeline/, docs/, config/ exist; if not, create them and note missing earlier phases in docs/PHASE_PLAN.md.

2) WRITE AIDER CONTRACT DOC
   - Create docs/aider_contract.md with:
     - Sections: Overview, Requirements, CLI Invocation, Environment, Git & Worktree Requirements, Error Handling, Contract Version.
     - Define CONTRACT_VERSION (e.g. AIDER_CONTRACT_V1) and document it.

3) DEFINE AIDER TOOL PROFILE
   - Edit config/tool_profiles.json to add a new "aider" profile.
   - Include reasonable defaults for:
     - command, args, env, working_dir, timeout_sec, success_exit_codes.
   - Document in comments or docs/ARCHITECTURE.md how {model_name}, {prompt_file}, {worktree_path} are supplied.

4) IMPLEMENT PROMPT ENGINE
   - Implement src/pipeline/prompts.py (or extend stub from PH-01) with:
     - build_edit_prompt(...)
     - build_fix_prompt(...)
     - Any helper functions needed to assemble context dictionaries.

   - Use Jinja2 (or another template engine) if available; if not yet installed, document that and use a simple Python format approach until Jinja can be added.

5) CREATE PROMPT TEMPLATES
   - Create templates/prompts/edit_prompt.txt.j2.
   - Create templates/prompts/fix_prompt.txt.j2.
   - Ensure prompts.py loads and renders these templates.

6) AIDER HELPER FUNCTIONS
   - Implement prepare_aider_prompt_file(...)
   - Implement run_aider_edit(...) and run_aider_fix(...).
   - Ensure they use run_tool("aider", ...) from src/pipeline/tools.py.
   - Ensure they record DB events/errors via tools.py + db.py.

7) SANDBOX & INTEGRATION TESTS
   - Create sandbox_repos/ with at least one small Python repo.
   - Implement tests/integration/test_aider_sandbox.py.
   - Ensure tests:
     - Skip gracefully if Aider is not installed.
     - Validate that prompt generation, prompt file writing, and Aider invocation path work end-to-end.

8) RUN TESTS
   - From project root:
     - Run: pytest
   - Fix any failing tests before marking the phase complete.

9) UPDATE DOCS
   - Update docs/ARCHITECTURE.md with the Aider integration & prompt engine section.
   - Update docs/PHASE_PLAN.md with detailed PH-03.5 content.

10) GIT COMMIT
   - Stage and commit with message:
     - "PH-03.5: Aider integration contract and prompt template system"

====================================
PHASE COMPLETION CHECKLIST
====================================

Before you consider PH-03.5 done, ensure all of the following are true:

[ ] docs/aider_contract.md exists and documents a clear Aider integration contract + CONTRACT_VERSION
[ ] config/tool_profiles.json has an "aider" profile with command/args/env/working_dir/timeout configured
[ ] src/pipeline/prompts.py implements build_edit_prompt(...) and build_fix_prompt(...)
[ ] templates/prompts/edit_prompt.txt.j2 and templates/prompts/fix_prompt.txt.j2 exist and are used by prompts.py
[ ] Helper(s) exist to write prompt files to <worktree>/.aider/prompts/ and to call run_tool("aider", ...) (run_aider_edit, run_aider_fix or equivalent)
[ ] sandbox_repos/ contains at least one small repo for Aider testing
[ ] tests/integration/test_aider_sandbox.py exists:
    - Invokes Aider via the new helpers (or skips if Aider is missing)
    - Verifies prompt files are created
    - Verifies events/errors are recorded when run_id/ws_id are provided
[ ] docs/ARCHITECTURE.md has an “Aider Integration & Prompt Engine” section
[ ] docs/PHASE_PLAN.md has an updated PH-03.5 section listing artifacts and behavior
[ ] A git commit with message like "PH-03.5: Aider integration contract and prompt template system" has been created

====================================
INTERACTION STYLE
====================================

- Do NOT ask the user questions unless you are completely blocked.
- Make reasonable assumptions (e.g., default model name) and clearly document them in:
  - docs/aider_contract.md
  - docs/PHASE_PLAN.md (PH-03.5 section)
- When you output your response, clearly separate:
  - PowerShell commands you would run.
  - JSON, Python, Markdown, and template file contents you would create or modify.

END OF PROMPT
