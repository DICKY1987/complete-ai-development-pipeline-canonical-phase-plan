{"path": "AI_NAVIGATION_SUMMARY.md", "name": "AI_NAVIGATION_SUMMARY.md", "preview": "# AI Navigation Implementation Summary\n\nThis document summarizes the AI navigation enhancements applied to the UET framework based on best practices for AI tool discoverability.\n\n## Implementation Date\n2025-11-23\n\n## Changes Made\n\n### 1. Root-Level Navigation Documents \u2705\n\nCreated **3 essential entry point documents**:\n\n#### `ARCHITECTURE.md`\n- **Purpose**: System mental model and execution flow\n- **Contents**:\n  - Mental model (DAG-based orchestration)\n  - Complete execution flow diagram\n  - Key concepts (Profile, Phase, Workstream, Task, Adapter)\n  - System layer architecture diagram\n  - Entr"}
{"path": "ARCHITECTURE.md", "name": "ARCHITECTURE.md", "preview": "# UET Architecture Guide\n\n## Mental Model\n\nUET is a **DAG-based orchestration system** for AI-driven development workflows.\n\n**Think of it as:** \"Airflow for AI agents\" - autonomous task scheduling, resilient execution, and comprehensive state management for any development workflow.\n\n## Core Concept\n\nThe Universal Execution Templates Framework enables AI agents to autonomously manage complex development workflows by providing:\n- **Schema-driven execution**: Type-safe operations with 17 JSON schemas\n- **Project-agnostic templates**: Pre-built profiles for any project type\n- **Resilient orchest"}
{"path": "CLAUDE.md", "name": "CLAUDE.md", "preview": "# CLAUDE.md\n\nThis file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.\n\n## Role & Context\n\nYou are working in the **Universal Execution Templates (UET) Framework**, a production-ready AI orchestration system for autonomous development workflows.\n\n**Framework Type**: Schema-driven, spec-first development\n**Status**: Phase 3 Complete (78% overall) - Orchestration Engine fully operational\n**Tests**: 196/196 passing (100%)\n**Language**: Python 3.8+\n\nThis is a **development framework repository**, not a target project. You'll be working on the orchestrat"}
{"path": "DEPENDENCIES.md", "name": "DEPENDENCIES.md", "preview": "# UET Framework Dependency Graph\n\n## Dependency Layers\n\nThe UET framework follows a strict layered architecture where dependencies flow downward only. Higher layers may depend on lower layers, but never the reverse.\n\n### Layer 0: Foundation (No Dependencies)\n\n**`schema/`** - JSON Schema definitions\n- Purpose: Type contracts for all operations\n- Dependencies: None\n- Used by: All modules for validation\n\n**`core/state/`** - State management\n- Purpose: Run state persistence, checkpoint management\n- Dependencies: None (SQLite standard library)\n- Used by: engine, bootstrap, adapters\n\n### Layer 1: Do"}
{"path": "GETTING_STARTED.md", "name": "GETTING_STARTED.md", "preview": "# Getting Started with UET\n\nQuick navigation guide for common tasks. Choose your path below.\n\n## I want to...\n\n### \ud83d\ude80 Bootstrap a new project\n\n**Quick start:**\n```bash\npython core/bootstrap/orchestrator.py /path/to/project\n```\n\n**With specific profile:**\n```bash\npython core/bootstrap/orchestrator.py /path/to/project --profile software-dev-python\n```\n\n**Learn more:**\n- Read: `specs/UET_BOOTSTRAP_SPEC.md`\n- See: `core/bootstrap/README.md`\n- Example: `profiles/software-dev-python/`\n\n---\n\n### \ud83c\udfd7\ufe0f Understand the architecture\n\n**Entry points:**\n- Read: `ARCHITECTURE.md` - System overview and mental mo"}
{"path": "INTEGRATION_ANALYSIS_SYNC_TO_UET.md", "name": "INTEGRATION_ANALYSIS_SYNC_TO_UET.md", "preview": "# Integration Analysis: Zero-Touch Git Sync \u2192 UET Framework\n\n**Document Purpose**: Comprehensive analysis for AI review\n**Created**: 2025-11-22\n**Author**: Claude (Sonnet 4.5)\n**Review Target**: Secondary AI verification system\n\n---\n\n## 1. TASK UNDERSTANDING\n\n### 1.1 Primary Objective\n\n**User Request**: Integrate the zero-touch git sync framework (currently a standalone system) into the Universal Execution Templates (UET) Framework as a reusable, project-agnostic subsystem.\n\n**Context Provided**:\n- User has a working zero-touch git sync system at `C:\\Users\\richg\\TODO_TONIGHT\\UET_ZERO_TOUCH_GIT"}
{"path": "PATCH_ANALYSIS.md", "name": "PATCH_ANALYSIS.md", "preview": "# Patch Analysis - Configuration Files Impact on UET V2 Master Plan\n\n**Generated**: 2025-11-23T11:01:12.785Z  \n**Purpose**: Analyze configuration files for required patches to `copiolt plan_uv2.json`  \n**Status**: CRITICAL - Multiple high-priority patches identified\n\n---\n\n## Executive Summary\n\n**5 configuration files** contain **critical information** that MUST be patched into the master plan:\n\n| File | Priority | Impact | Patches Needed |\n|------|----------|--------|----------------|\n| **CODEBASE_INDEX.yaml** | CRITICAL | Module structure, dependencies, 3 engines | 15+ patches |\n| **ai_polici"}
{"path": "README.md", "name": "README.md", "preview": "# Universal Execution Templates (UET) Framework\n\n> A comprehensive AI development pipeline system for orchestrating autonomous workflows across any project type.\n\n[![Tests](https://img.shields.io/badge/tests-196%2F196%20passing-success)]()\n[![Progress](https://img.shields.io/badge/progress-78%25-blue)]()\n[![Phase](https://img.shields.io/badge/phase-3%20complete-brightgreen)]()\n\n## Overview\n\nThe **Universal Execution Templates Framework** is a production-ready orchestration system that enables AI agents to autonomously manage complex development workflows. It provides schema-driven execution, r"}
{"path": "master_plan/ADR_PATCH_ANALYSIS.md", "name": "ADR_PATCH_ANALYSIS.md", "preview": "# ADR Architecture Decisions Patch Analysis\n\n**Patch ID**: 005-adr-architecture-decisions  \n**Created**: 2025-11-23T11:23:26.442Z  \n**Priority**: HIGH  \n**Operations**: 11\n\n---\n\n## Overview\n\nThis patch integrates **10 Architecture Decision Records (ADRs)** that document critical architectural choices, their rationale, consequences, and rejected alternatives. ADRs provide essential context for AI agents and developers to understand WHY decisions were made, not just WHAT was implemented.\n\n---\n\n## Source Files (10 ADRs)\n\n### Core System Architecture\n1. **ADR-0001: Workstream Model Choice** - Core"}
{"path": "master_plan/COMPLETE_PATCH_SUMMARY.md", "name": "COMPLETE_PATCH_SUMMARY.md", "preview": "# Complete Patch Integration Summary\n\n**Date**: 2025-11-23  \n**Status**: \u2705 ALL 7 PATCHES READY TO APPLY\n\n---\n\n## Executive Summary\n\nCreated **7 comprehensive patches** integrating **50 source files** with **129 JSON Patch operations** into the UET V2 Master Plan. These patches capture:\n\n- \u2705 **Complete UET V2 specifications** (state machines, contracts, DAG scheduler)\n- \u2705 **Full implementation details** (~1,667 lines of production code)\n- \u2705 **18 JSON Schema contracts** (formal data contracts)\n- \u2705 **50+ tests** (~75% code coverage)\n- \u2705 **Configuration & documentation** (AI policies, quality gate"}
{"path": "master_plan/CORE_ENGINE_PATCH_ANALYSIS.md", "name": "CORE_ENGINE_PATCH_ANALYSIS.md", "preview": "# Patch 005: Core Engine Implementation Analysis\n\n**Created**: 2025-11-23T11:26:45.366Z  \n**Patch File**: `005-core-engine-implementation.json`  \n**Priority**: HIGH  \n**Operations**: 20 patches\n\n---\n\n## Overview\n\nThis patch integrates **existing implementation details** from `core/engine/` into the UET V2 Master Plan. Analysis of 8 files reveals **70-90% complete implementations** of critical engine components.\n\n---\n\n## Source Files Analyzed\n\n1. **core/engine/orchestrator.py** (347 lines) - WS-03-01A\n2. **core/engine/scheduler.py** (271 lines) - WS-03-01C  \n3. **core/engine/state_machine.py** "}
{"path": "master_plan/CORE_STATE_IMPLEMENTATION_PATCH_ANALYSIS.md", "name": "CORE_STATE_IMPLEMENTATION_PATCH_ANALYSIS.md", "preview": "# Patch 006: Core State Implementation Analysis\n\n**Patch ID**: 006-core-state-implementation  \n**Created**: 2025-11-23T11:38:49.896Z  \n**Priority**: HIGH  \n**Status**: Ready for Application\n\n---\n\n## Source Files Analyzed\n\n1. **UNIVERSAL_EXECUTION_TEMPLATES_FRAMEWORK/core/state/db.py** (370 lines)\n   - Database class implementation\n   - SQLite schema definitions\n   - CRUD operations for runs, step_attempts, run_events\n   - Singleton pattern for database access\n\n---\n\n## What This Patch Adds\n\n### 1. Implementation Metadata (`/implementation/core_state`)\n\n**Module Status**:\n- **Status**: IMPLEMENT"}
{"path": "master_plan/CREATION_SUCCESS_REPORT.md", "name": "CREATION_SUCCESS_REPORT.md", "preview": "# UET V2 Master Plan - Creation Success Report\n\n**Created**: 2025-11-23T13:29:16.000Z  \n**Status**: \u2705 **SUCCESSFULLY CREATED**  \n**File**: `UET_V2_MASTER_PLAN.json`  \n**Size**: 134 KB\n\n---\n\n## Summary\n\n\ud83c\udf89 **MASTER PLAN SUCCESSFULLY CREATED!**\n\nThe UET V2 Master Plan has been generated by applying **8 patches** (**53 operations**) to the base plan.\n\n---\n\n## File Details\n\n| Property | Value |\n|----------|-------|\n| **Filename** | UET_V2_MASTER_PLAN.json |\n| **Location** | PATCH_PLAN_JSON/ |\n| **Size** | 134 KB |\n| **Format** | JSON (valid) |\n| **Created** | 2025-11-23 07:29:16 |\n\n---\n\n## Patches "}
{"path": "master_plan/DEVELOPMENT_GUIDELINES_PATCH_ANALYSIS.md", "name": "DEVELOPMENT_GUIDELINES_PATCH_ANALYSIS.md", "preview": "# Patch 005: Development Guidelines Integration Analysis\n\n**Patch ID**: 005-development-guidelines  \n**Created**: 2025-11-23T11:23:15.523Z  \n**Priority**: HIGH  \n**Status**: Ready for Application\n\n---\n\n## Source Files Analyzed\n\n1. **UET_DEVELOPMENT RULES DO and DONT.md** (274 lines)\n   - Mandatory practices (8 rules)\n   - Anti-patterns catalog (6 patterns)\n   - Golden workflow\n   - Success metrics\n\n2. **AI_DEV_HYGIENE_GUIDELINES.md** (493 lines)\n   - Core principles (3)\n   - Directory organization rules\n   - File naming standards\n   - Context priority levels\n   - Quarterly maintenance routine\n"}
{"path": "master_plan/DOCUMENTATION_PATCH_ANALYSIS.md", "name": "DOCUMENTATION_PATCH_ANALYSIS.md", "preview": "# Documentation Patch Analysis\n\n**Generated**: 2025-11-23T11:07:25Z  \n**Purpose**: Analyze documentation files for master plan patches  \n**Status**: HIGH PRIORITY - Critical AI tooling and execution patterns identified\n\n---\n\n## Executive Summary\n\n**6 documentation files analyzed** - **4 contain CRITICAL information** for master plan:\n\n| File | Priority | Impact | Patches |\n|------|----------|--------|---------|\n| **tools-instructions-config.md** | CRITICAL | Multi-tool instruction patterns | 8 patches |\n| **soft-sandbox-pattern.md** | HIGH | Sandbox isolation strategy | 6 patches |\n| **ai-deve"}
{"path": "master_plan/EXISTING_TEST_COVERAGE_SUMMARY.md", "name": "EXISTING_TEST_COVERAGE_SUMMARY.md", "preview": "# Existing Test Coverage Summary\n\n**Location**: `UNIVERSAL_EXECUTION_TEMPLATES_FRAMEWORK/tests/engine`  \n**Status**: Tests exist, implementation status varies  \n**Generated**: 2025-11-23\n\n---\n\n## Test Files Found\n\n### 1. test_routing.py (422 lines)\n**Components Tested**:\n- `TaskRouter` class\n- `ExecutionRequestBuilder` class\n- Router configuration loading\n- Task routing logic\n- Capability matching\n- Routing strategies (fixed, round_robin, auto)\n\n**Test Classes** (8):\n1. `TestRouterInitialization` - Config loading, apps, routing rules\n2. `TestTaskRouting` - High/low risk routing, fallback logic"}
{"path": "master_plan/MASTER_PLAN_DELIVERABLES.md", "name": "MASTER_PLAN_DELIVERABLES.md", "preview": "# UET V2 Master Plan - What It Delivers\n\n**Document**: Master Plan Deliverables & Purpose  \n**Generated**: 2025-11-23T13:23:30.771Z  \n**Audience**: Users, developers, AI agents\n\n---\n\n## TL;DR - What You Get\n\n**`UET_V2_MASTER_PLAN.json`** is a **single source of truth** containing:\n\n\u2705 **Complete system blueprint** - Architecture, patterns, decisions  \n\u2705 **Implementation roadmap** - What's built (78%), what's planned (22%)  \n\u2705 **Design documentation** - ADRs, principles, rejected alternatives  \n\u2705 **Technical specifications** - State machines, contracts, schemas  \n\u2705 **Operational guidance** - Too"}
{"path": "master_plan/MASTER_PLAN_STATUS.md", "name": "MASTER_PLAN_STATUS.md", "preview": "# UET V2 Master Plan - Current Status Report\n\n**Generated**: 2025-11-23T13:02:30.550Z  \n**Status**: \ud83d\udccb READY TO BUILD\n\n---\n\n## Current State\n\n### Master Plan File\n\u274c **`UET_V2_MASTER_PLAN.json` does NOT exist yet**  \n\u2705 **Base plan exists**: `base_plan.json` (0.2 KB)  \n\u2705 **Alternative base**: `copiolt plan_uv2.json` (63.9 KB)\n\n**Action Required**: Run `python apply_patches.py` to create master plan\n\n---\n\n## Patch Files Ready to Merge\n\n### Total Patches: 8 (targeting our custom patches)\n\n| # | Patch File | Size | Operations | Status | What It Adds |\n|---|------------|------|------------|--------|-"}
{"path": "master_plan/MASTER_PLAN_SUMMARY.md", "name": "MASTER_PLAN_SUMMARY.md", "preview": "# UET V2 Master Plan - Summary\n\n**Generated**: 2025-11-23T11:18:02Z  \n**Purpose**: Executive summary of all patches ready to apply  \n**Status**: READY FOR EXECUTION\n\n---\n\n## Overview\n\n**7 patch files** containing **129 operations** are ready to merge into **UET_V2_MASTER_PLAN.json**.\n\n---\n\n## Patch Summary\n\n| Patch | Source Files | Operations | What It Adds |\n|-------|--------------|------------|--------------|\n| **001** | 5 config files | 22 | Architecture, 3-engine problem, existing components, policies, Phase 7 |\n| **002** | 4 doc files | 15 | AI tool config, sandbox strategy, documentation"}
{"path": "master_plan/PATCH_005_SUMMARY.md", "name": "PATCH_005_SUMMARY.md", "preview": "# Patch 005 Creation Summary\n\n**Date**: 2025-11-23  \n**Patch ID**: 005-core-engine-implementation  \n**Status**: \u2705 CREATED AND INTEGRATED\n\n---\n\n## What Was Created\n\n### 1. Main Patch File\n**File**: `005-core-engine-implementation.json`  \n**Size**: 18,920 characters  \n**Operations**: 20 JSON Patch operations (RFC 6902)\n\n### 2. Analysis Document\n**File**: `CORE_ENGINE_PATCH_ANALYSIS.md`  \n**Size**: 7,656 characters  \n**Purpose**: Detailed analysis of findings and impact\n\n---\n\n## Source Analysis\n\nAnalyzed **8 files** in `core/engine/`:\n\n1. \u2705 `orchestrator.py` (347 lines, 85% complete)\n2. \u2705 `schedu"}
{"path": "master_plan/PATCH_006_SUMMARY.md", "name": "PATCH_006_SUMMARY.md", "preview": "# Patch 006 Creation Summary\n\n**Date**: 2025-11-23  \n**Patch ID**: 006-schema-definitions  \n**Status**: \u2705 CREATED AND INTEGRATED\n\n---\n\n## What Was Created\n\n### 1. Main Patch File\n**File**: `006-schema-definitions.json`  \n**Size**: 19,283 characters  \n**Operations**: 17 JSON Patch operations (RFC 6902)\n\n### 2. Analysis Document\n**File**: `SCHEMA_PATCH_ANALYSIS.md`  \n**Size**: 10,134 characters  \n**Purpose**: Detailed schema analysis and implementation guide\n\n---\n\n## Source Analysis\n\nAnalyzed **18 schema files** in `schema/`:\n\n### Documented in Detail (8 schemas)\n\n1. \u2705 `run_record.v1.json` - Run"}
{"path": "master_plan/PATCH_007_SUMMARY.md", "name": "PATCH_007_SUMMARY.md", "preview": "# Patch 007: Tool Adapter Interface - Summary\n\n**Created**: 2025-11-23T11:38:26.103Z  \n**Status**: \u2705 READY TO APPLY  \n**Priority**: MEDIUM\n\n---\n\n## What Was Done\n\n\u2705 **Analyzed 3 adapter implementation files**  \n\u2705 **Created patch file**: `007-tool-adapter-interface.json` (3 operations)  \n\u2705 **Created analysis doc**: `TOOL_ADAPTER_PATCH_ANALYSIS.md`  \n\u2705 **Updated apply_patches.py** to include new patch\n\n---\n\n## Source Files Analyzed\n\n**Implementation code** (358 lines total):\n\n1. **`core/adapters/base.py`** (123 lines)\n   - `ToolConfig` - Tool configuration dataclass\n   - `ExecutionResult` - Resu"}
{"path": "master_plan/PATCH_008_SUMMARY.md", "name": "PATCH_008_SUMMARY.md", "preview": "# Patch 008: Resilience Patterns - Summary\n\n**Created**: 2025-11-23T12:15:26.788Z  \n**Status**: \u2705 READY TO APPLY  \n**Priority**: HIGH\n\n---\n\n## What Was Done\n\n\u2705 **Analyzed 3 resilience test files** (523 lines total)  \n\u2705 **Created patch file**: `008-resilience-patterns.json` (2 operations)  \n\u2705 **Updated apply_patches.py** to include resilience patch\n\n---\n\n## Test Files Analyzed (3 files, 523 lines)\n\n### 1. `test_circuit_breaker.py` (176 lines)\n**10 tests** covering circuit breaker pattern\n\n### 2. `test_retry.py` (184 lines)  \n**11 tests** covering SimpleRetry and ExponentialBackoff\n\n### 3. `test"}
{"path": "master_plan/PATCH_009_SUMMARY.md", "name": "PATCH_009_SUMMARY.md", "preview": "# Patch 009: Sub-Agent Architecture & Slash Commands - Summary\n\n**Created**: 2025-11-23T12:57:11.337Z  \n**Status**: \u2705 READY TO APPLY  \n**Priority**: HIGH\n\n---\n\n## What Was Done\n\n\u2705 **Analyzed agents and custom commands architecture document**  \n\u2705 **Created patch file**: `009-subagent-architecture-slash-commands.json` (3 operations)  \n\u2705 **Updated apply_patches.py** to include sub-agent patch  \n\u2705 **Defined 20+ sub-agents across 5 categories**  \n\u2705 **Specified 15+ slash commands for user-initiated workflows**\n\n---\n\n## Overview\n\nThis patch documents a **three-tier architecture** that decomposes mono"}
{"path": "master_plan/PATCH_APPLICATION_GUIDE.md", "name": "PATCH_APPLICATION_GUIDE.md", "preview": "# UET V2 Master Plan - Patch Application Guide\n\n**Version**: 1.0.0  \n**Last Updated**: 2025-11-23T11:07:25Z  \n**Purpose**: Instructions for applying patches to master plan\n\n---\n\n## Available Patches\n\n| Patch ID | File | Priority | Operations | Status |\n|----------|------|----------|------------|--------|\n| 001 | `001-config-integration.json` | CRITICAL | 22 | Ready |\n| 002 | `002-documentation-integration.json` | CRITICAL | 15 | Ready |\n| 003 | `003-uet-v2-specifications.json` | CRITICAL | 25 | Ready |\n| 004 | `004-planning-reference.json` | CRITICAL | 18 | Ready |\n\n**Total Operations**: 80 pa"}
{"path": "master_plan/PATCH_DEPENDENCY_ANALYSIS.md", "name": "PATCH_DEPENDENCY_ANALYSIS.md", "preview": "# Patch Dependency Analysis & Conflict Resolution Report\n\n**Generated**: 2025-11-23T13:18:48.406Z  \n**Status**: \u2705 **CONFLICTS RESOLVED - READY TO APPLY**\n\n---\n\n## Executive Summary\n\n\u2705 **All conflicts fixed**  \n\u2705 **8 patches validated**  \n\u2705 **53 unique paths** (no overlaps)  \n\u2705 **99 operations** ready to apply  \n\u2705 **Correct application order** determined\n\n---\n\n## Conflicts Found & Fixed\n\n### Issue: `/meta/patch_metadata` Path Collision\n\n**Problem**: Patches 001-004 were all trying to `add` to the same path `/meta/patch_metadata`\n\n**Impact**: First patch would succeed, subsequent patches would f"}
{"path": "master_plan/PLANNING_REFERENCE_PATCH_ANALYSIS.md", "name": "PLANNING_REFERENCE_PATCH_ANALYSIS.md", "preview": "# Planning & Reference Documentation Patch Analysis\n\n**Generated**: 2025-11-23T11:16:48Z  \n**Purpose**: Analyze planning and reference docs for master plan patches  \n**Status**: CRITICAL - Complete phase plans and error catalog identified\n\n---\n\n## Executive Summary\n\n**13 files analyzed** - **6 contain CRITICAL implementation details**:\n\n| File | Priority | Content | Impact |\n|------|----------|---------|--------|\n| **PHASE_UET_INTEGRATION.md** | CRITICAL | Complete 9-10 week phase plan | Full implementation roadmap |\n| **PHASE_UET_CHECKLIST.md** | CRITICAL | Detailed checklist with hour estima"}
{"path": "master_plan/SCHEMA_PATCH_ANALYSIS.md", "name": "SCHEMA_PATCH_ANALYSIS.md", "preview": "# Patch 006: Schema Definitions Analysis\n\n**Created**: 2025-11-23T11:40:15.088Z  \n**Patch File**: `006-schema-definitions.json`  \n**Priority**: CRITICAL  \n**Operations**: 17 patches\n\n---\n\n## Overview\n\nThis patch integrates **18 JSON Schema definitions** from the `schema/` directory into the UET V2 Master Plan. These schemas define **formal data contracts** for all core system entities.\n\n---\n\n## Source Files Analyzed\n\n### Core Schemas (8 documented)\n\n1. **run_record.v1.json** - Top-level execution record\n2. **step_attempt.v1.json** - Tool invocation within a run\n3. **patch_ledger_entry.v1.json*"}
{"path": "master_plan/TEST_ADAPTER_ANALYSIS.md", "name": "TEST_ADAPTER_ANALYSIS.md", "preview": "# Tool Adapter Tests - Analysis Summary\n\n**Analyzed**: 2025-11-23T12:07:00Z  \n**Test Directory**: `tests/adapters/`  \n**Status**: \u2705 COMPREHENSIVE TEST COVERAGE\n\n---\n\n## Test Files Found (4 files, 496 lines)\n\n### 1. `test_base.py` (153 lines)\n\n**Test Classes**: 2  \n**Test Methods**: 13\n\n#### TestToolConfig (7 tests)\n- \u2705 `test_create_tool_config` - Verify config creation\n- \u2705 `test_supports_task_matching` - Task kind matching (code_edit, analysis)\n- \u2705 `test_supports_task_with_domain` - Domain filtering (python, rust, javascript)\n- \u2705 `test_get_timeout_default` - Default 300s timeout\n- \u2705 `test_get_"}
{"path": "master_plan/TEST_INFRASTRUCTURE_PATCH_ANALYSIS.md", "name": "TEST_INFRASTRUCTURE_PATCH_ANALYSIS.md", "preview": "# Patch 007: Test Infrastructure Analysis\n\n**Created**: 2025-11-23T12:10:22.447Z  \n**Patch File**: `007-test-infrastructure.json`  \n**Priority**: HIGH  \n**Operations**: 12 patches\n\n---\n\n## Overview\n\nThis patch integrates **test infrastructure documentation** from the `tests/` directory. Analysis of **18 test files** reveals **~75% test coverage** of core modules with comprehensive pytest-based testing.\n\n---\n\n## Source Files Analyzed\n\n### Test Files by Category (18 total)\n\n#### Bootstrap (1 file)\n- **test_validator.py** - 10 tests for bootstrap validation\n\n#### Schema (2 files)\n- **test_all_sch"}
{"path": "master_plan/TOOL_ADAPTER_PATCH_ANALYSIS.md", "name": "TOOL_ADAPTER_PATCH_ANALYSIS.md", "preview": "# Tool Adapter Interface Patch Analysis\n\n**Patch ID**: 006-tool-adapter-interface  \n**Created**: 2025-11-23T11:38:26.103Z  \n**Priority**: MEDIUM  \n**Operations**: 3\n\n---\n\n## Overview\n\nThis patch documents the **Tool Adapter Interface Pattern** - a critical abstraction that decouples task execution from specific tool implementations. It enables the system to route tasks (code editing, testing, validation) to external tools (aider, pytest, git) through a uniform interface.\n\n---\n\n## Source Files (3 Implementation Files)\n\n1. **`core/adapters/base.py`** (123 lines)\n   - `ToolConfig` - Tool configur"}
{"path": "master_plan/UET_V2_SPECS_PATCH_ANALYSIS.md", "name": "UET_V2_SPECS_PATCH_ANALYSIS.md", "preview": "# UET V2 Specifications Patch Analysis\n\n**Generated**: 2025-11-23T11:12:14Z  \n**Purpose**: Analyze UET V2 specification files for master plan patches  \n**Status**: CRITICAL - Core UET V2 technical specifications identified\n\n---\n\n## Executive Summary\n\n**5 UET V2 specification files analyzed** - **ALL contain CRITICAL technical details**:\n\n| File | Priority | Content | Impact |\n|------|----------|---------|--------|\n| **STATE_MACHINES.md** | CRITICAL | 3 state machines with transitions | Defines component behavior |\n| **COMPONENT_CONTRACTS.md** | CRITICAL | 10 component API contracts | Enables p"}
{"path": "profiles/README.md", "name": "README.md", "preview": "# Project Profiles\n\nPre-built configuration templates for different project types. Each profile contains tool routing, phase definitions, and domain-specific workflows.\n\n## Available Profiles\n\n### software-dev-python/\n**When to use**: Python projects with testing, linting, code editing needs\n\n**Languages**: Python (primary)\n\n**Tools**: \n- **Code editing**: aider, cursor\n- **Testing**: pytest, unittest\n- **Linting**: ruff, pylint, black\n- **Type checking**: mypy, pyright\n- **Version control**: git\n\n**Phases**:\n1. **analyze** - Code analysis, dependency checking\n2. **implement** - Code editing, "}
{"path": "schema/README.md", "name": "README.md", "preview": "# UET Schema Catalog\n\nComplete reference for all JSON schemas defining the UET framework's type contracts.\n\n## Schema Overview\n\nThe UET framework uses **17 JSON schemas (v1)** to ensure type-safe operations across all modules. Every data structure is validated against its schema before use.\n\n## Schema Categories\n\n### Execution Schemas\n\nSchemas defining task execution and workflow orchestration.\n\n#### `execution_request.v1.json`\n**Purpose**: Format for requesting tool execution via adapters\n\n**Structure**:\n```json\n{\n  \"action\": \"code_edit\",\n  \"domain\": \"python\",\n  \"context\": {\n    \"files\": [\"ma"}
{"path": "specs/# Comprehensive Integration Specification Enhanced Prompt Engineering.md", "name": "# Comprehensive Integration Specification Enhanced Prompt Engineering.md", "preview": "# Comprehensive Integration Specification: Enhanced Prompt Engineering for Production AI Development Pipeline\n\n**Document Type**: Technical Integration Specification  \n**Optimization**: Agentic AI Autonomous Execution  \n**Version**: 1.0  \n**Date**: 2025-11-19  \n**Scope**: Complete integration of advanced prompt engineering patterns into operational orchestration infrastructure\n\n---\n\n## SECTION 1: EXECUTIVE CONTEXT & SYSTEM STATE\n\n### 1.1 Current System Architecture\n\n**System Name**: Complete AI Development Pipeline - Canonical Phase Plan  \n**Primary Function**: Automated software development t"}
{"path": "specs/# Patch Files as Unified Diff & Optimal .md", "name": "# Patch Files as Unified Diff & Optimal .md", "preview": "# Patch Files as Unified Diff & Optimal Handoff Format*For Agentic AI Pipelines and Multi-CLI Workflows*\n\n\n\n---\n\n## 0. Purpose of This Document\n\nThis document combines and normalizes two source docs:\n\n* **\u201cpatch files are in unified diff_format.md\u201d**\n* **\u201cpatch files are an optimal handoff format.md\u201d**\n\nGoal:\n\n* Explain **what patch files are**, in unified diff format.\n* Explain **how they work** (create, apply, conflict handling).\n* Describe **where they are the best possible handoff artifact** between tools/agents.\n* Describe **where they are *not* ideal** and what to use instead.\n* Provide "}
{"path": "specs/PHASE_3_COMPLETION_REPORT.md", "name": "PHASE_3_COMPLETION_REPORT.md", "preview": "# Phase 3 Completion Report\n\n**Date:** 2025-11-21  \n**Phase:** 3 - Orchestration Engine  \n**Status:** \u2705 COMPLETE (100%)  \n**Duration:** 3 sessions (~2.5 hours)\n\n---\n\n## Executive Summary\n\nPhase 3 has been completed successfully, delivering a production-ready orchestration engine for the Universal Execution Templates Framework. All 6 workstreams were implemented with comprehensive testing, achieving 100% test pass rate.\n\n**Key Achievement:** Built a complete autonomous workflow execution system with resilience patterns and real-time monitoring in just 2.5 hours across 3 focused sessions.\n\n---\n\n"}
{"path": "specs/PHASE_3_PLAN.md", "name": "PHASE_3_PLAN.md", "preview": "# Phase 3: Orchestration Engine - Implementation Plan\n\n**Date:** 2025-11-20  \n**Status:** \ud83d\ude80 STARTING  \n**Estimated Duration:** 15 days (3 weeks)  \n**Current Progress:** 0%\n\n---\n\n## Overview\n\nPhase 3 builds the runtime orchestration system that executes workstreams autonomously. This is the core execution engine that:\n- Manages workstream runs and state\n- Routes tasks to appropriate tools\n- Handles retries and circuit breakers\n- Tracks progress and generates reports\n\n---\n\n## Architecture\n\n```\nPhase 3: Orchestration Engine\n\u251c\u2500\u2500 PH-03-01: Core Orchestrator\n\u2502   \u251c\u2500\u2500 WS-03-01A: Run Management (6 days"}
{"path": "specs/PHASE_4_AI_ENHANCEMENT_PLAN.md", "name": "PHASE_4_AI_ENHANCEMENT_PLAN.md", "preview": "# Phase 4: AI Enhancement - Advanced Codebase Intelligence\n\n**Created:** 2025-11-22  \n**Phase ID:** PH-04-AI-ENH  \n**Estimated Duration:** 6-8 weeks  \n**Prerequisites:** Phase 3 Complete (Orchestration Engine)  \n**Status:** Planning\n\n---\n\n## Executive Summary\n\nThis phase implements cutting-edge AI-assisted development techniques to enhance the pipeline with:\n- **AST-based repository mapping** (Tree-sitter + PageRank)\n- **GraphRAG** for semantic code understanding\n- **Reflexion loops** for autonomous error correction\n- **RAPTOR** for hierarchical code indexing\n- **Episodic memory** for learning"}
{"path": "specs/PHASE_4_IMPLEMENTATION_SUMMARY.md", "name": "PHASE_4_IMPLEMENTATION_SUMMARY.md", "preview": "# Phase 4: AI Enhancement - Implementation Summary\n\n**Created:** 2025-11-22  \n**Status:** \u2705 Planning Complete - Ready for Execution  \n**Location:** `UNIVERSAL_EXECUTION_TEMPLATES_FRAMEWORK/specs/`\n\n---\n\n## \ud83d\udce6 Deliverables Created\n\n### 1. Core Planning Documents\n\n\u2705 **PHASE_4_AI_ENHANCEMENT_PLAN.md** (19.8 KB)\n- Complete 6-week phase plan\n- 12 workstreams across 3 major areas\n- Detailed acceptance criteria for each workstream\n- Cost estimates and risk mitigation\n- Research paper references\n\n\u2705 **PHASE_4_QUICK_REFERENCE.md** (9.2 KB)\n- Quick start guide for developers\n- Usage examples for each feat"}
{"path": "specs/PHASE_4_QUICK_REFERENCE.md", "name": "PHASE_4_QUICK_REFERENCE.md", "preview": "# Phase 4 Quick Reference: AI Enhancement Features\n\n**Version:** 1.0.0  \n**Phase:** PH-04-AI-ENH  \n**Status:** Planning\n\n---\n\n## \ud83c\udfaf What Phase 4 Delivers\n\n**Transform from:** Workflow orchestrator  \n**Transform to:** Intelligent AI assistant that learns, adapts, and self-corrects\n\n### 7 Major Capabilities\n\n| Capability | What It Does | User Benefit |\n|-----------|--------------|--------------|\n| **AST Repository Map** | Compress codebase into signature-only view | 10x smaller context, no hallucinations |\n| **GraphRAG** | Semantic code understanding via knowledge graphs | \"What breaks if I chang"}
{"path": "specs/PROGRESS_CHECKPOINT_2025-11-20.md", "name": "PROGRESS_CHECKPOINT_2025-11-20.md", "preview": "# Universal Execution Templates Framework - Progress Report\n\n**Date:** 2025-11-20  \n**Status:** Phase 0 Complete, Phase 1 Partial (60% complete)  \n**Total Implementation Time:** ~2 hours  \n\n---\n\n## Executive Summary\n\nThe Universal Execution Templates (UET) Framework has successfully completed its foundational schema layer and established the profile system architecture. The framework is now capable of validating all core data structures and has profiles ready for 5 different project domains.\n\n**Key Achievement:** We've built a **schema-first, project-agnostic framework** that can be autonomous"}
{"path": "specs/PROGRESS_CHECKPOINT_2025-11-20_PHASE3.md", "name": "PROGRESS_CHECKPOINT_2025-11-20_PHASE3.md", "preview": "# Session Checkpoint: Phase 3 Progress\n\n**Date:** 2025-11-20 22:25 UTC  \n**Session Duration:** ~2 hours  \n**Status:** WS-03-01A COMPLETE, WS-03-01B Starting\n\n---\n\n## \ud83c\udf89 Major Accomplishments\n\n### WS-03-01A: Run Management - COMPLETE \u2705\n\n**Delivered 4 major components in ~2 hours:**\n\n1. **Database Layer** (`core/state/db.py`)\n   - 368 lines of production code\n   - SQLite backend with 3 tables (runs, step_attempts, run_events)\n   - Full CRUD operations\n   - JSON metadata support\n   - Singleton pattern\n\n2. **State Machine** (`core/engine/state_machine.py`)\n   - 210 lines\n   - Run state machine: 6 s"}
{"path": "specs/STATUS.md", "name": "STATUS.md", "preview": "# Framework Status Summary\n\n**Date:** 2025-11-22 20:41 UTC\n**Overall Progress:** 78% Complete (Phase 3 Done, Phase 4 Planned)\n\n## Completed \u2705\n- Phase 0: Schema Foundation (100%)\n  - 17 JSON schemas created and validated\n  - 22 tests passing\n  - Complete coverage of all framework artifacts\n\n- Phase 1: Profile System (60%)\n  - 5 domain profiles created\n  - All profiles validate\n  - Software-dev-python has full phase templates\n\n- Phase 2: Bootstrap Implementation (100%) - PHASE COMPLETE!\n  - \u2705 WS-02-01A: Project Scanner (discovery.py)\n  - \u2705 WS-02-01B: Profile Selector (selector.py)\n  - \u2705 WS-02-02"}
{"path": "specs/UET_BOOTSTRAP_SPEC.md", "name": "UET_BOOTSTRAP_SPEC.md", "preview": "# BOOTSTRAP_SPEC - Framework Self-Installation Guide for AI Agents\n\n```yaml\n---\nmeta_version: \"doc-meta.v1\"\ndoc_ulid: \"01JDCQM8XXXXXXXXXXXXXXXXXXX\"  # Generate actual ULID on commit\ndoc_type: \"core_spec\"\ndoc_layer: \"framework\"\ntitle: \"Universal Execution Templates Bootstrap Specification\"\nsummary: \"Defines how an AI agent autonomously analyzes, profiles, and instantiates this framework on any new project or module.\"\nversion: \"1.0.0\"\nstatus: \"active\"\nschema_ref: \"schema/bootstrap_spec.v1.json\"\ncreated_at: \"2025-11-20T20:29:00Z\"\nupdated_at: \"2025-11-20T20:29:00Z\"\nauthor_type: \"mixed\"\nowner: \"SYS"}
{"path": "specs/UET_CHAT_1.md", "name": "UET_CHAT_1.md", "preview": "Got it \u2014 I\u2019ll stay in planning/architecture mode only and **won\u2019t** start drafting any actual documents yet.\n\nBased on the project knowledge you\u2019ve fed in, here\u2019s how I\u2019d frame the *documentation suite* we should design next, plus how it ties back to what already exists.\n\n---\n\n## 1. What the current knowledge base is already telling us\n\nFrom the files, you already have the core \u201corg chart\u201d for an agentic documentation system:\n\n* **Agent Operations as the top brain**\n  `AGENT_OPERATIONS_SPEC v1.0` explicitly organizes the world into four specs:\n\n  * `PROMPT_RENDERING_SPEC`\n  * `TASK_ROUTING_SPE"}
{"path": "specs/UET_COOPERATION_SPEC.md", "name": "UET_COOPERATION_SPEC.md", "preview": "Here\u2019s a structured formalization of **COOPERATION_SPEC** as a *framework-level spec*, in the same style as the others (PROMPT / TASK_ROUTING / PATCH).\n\nNo prose doc, just: **objects, schemas, and behavior rules**.\n\n---\n\n## 1. Role & Position of COOPERATION_SPEC\n\n**Doc meta**\n\n* `doc_type`: `core_spec`\n* `doc_layer`: `framework`\n* `schema_ref`: `schema/cooperation_spec.v1.json`\n\n**Responsibility**\n\nCOOPERATION_SPEC defines:\n\n1. The **run/step/event model** for multi-tool cooperation.\n2. The **worker & queue model** (who does what, and where).\n3. The **zone model** (EDIT / STATIC / RUNTIME) and"}
{"path": "specs/UET_Error Pipeline a Card_Ledger _Registry system.md", "name": "UET_Error Pipeline a Card_Ledger _Registry system.md", "preview": "Yes\u2014these docs give you a *lot* of reusable patterns we can steal for the error-pipeline module. I\u2019ll keep this at the \u201cideas + wiring\u201d level, no new documents.\n\nI\u2019ll group the opportunities into themes:\n\n---\n\n## 1. Make the Error Pipeline a Card \u2192 Ledger \u2192 Registry system\n\nIn the docs module, every doc is a product with: **Doc Card \u2192 Ledger \u2192 Registry**, plus DDS and CI gates. \n\nYou can mirror this for the error pipeline:\n\n* **ErrorPatchCard (or ErrorCaseCard)**\n  YAML per patch / error case:\n\n  * `ulid`, `key` (e.g. `ERR_PATCH_2025_001`),\n  * `source_phase_id` / `source_run_id`,\n  * `files_t"}
{"path": "specs/UET_EXECUTION_KERNEL_PARALLELISM_STRATEGY_SPEC_V2.md", "name": "UET_EXECUTION_KERNEL_PARALLELISM_STRATEGY_SPEC_V2.md", "preview": "\n\n---\n\n# EXECUTION_KERNEL_PARALLELISM_STRATEGY_SPEC_V2\n\n## 0. Purpose and Context\n\nThis document defines a **parallelism-aware, deterministic execution kernel** for a multi-CLI, multi-agent software development pipeline.\n\nIt:\n\n1. Preserves the core model from `EXECUTION_KERNEL_PARALLELISM_STRATEGY_SPEC_V1`.\n2. Incorporates an external AI assessment that identified key gaps:\n\n   * merge strategy,\n   * state persistence,\n   * inter-worker coordination,\n   * context management,\n   * plan validation,\n   * cost tracking,\n   * test feedback loops,\n   * human review workflow,\n   * rollback/undo,\n   *"}
{"path": "specs/UET_Framework File Inventory (Project-Agnostic Core + Profiles + Examples.md", "name": "UET_Framework File Inventory (Project-Agnostic Core + Profiles + Examples.md", "preview": "Here\u2019s a single document you can drop into the repo as your **\u201cwhat files belong in the framework\u201d** map.\n\nI\u2019ll keep it project-agnostic and call out where things are:\n\n* **Core (generic, re-usable everywhere)**\n* **Profiles (software-dev flavored, optional)**\n* **Examples (error-pipeline etc., clearly non-core)**\n\nYou can rename paths, but this gives you a concrete file set.\n\n---\n\n# Framework File Inventory (Project-Agnostic Core + Profiles + Examples)\n\n## 0. Top-Level Layout\n\nRecommended high-level structure:\n\n```text\n/framework\n  /specs            # All schema & spec files (core + profiles)"}
{"path": "specs/UET_generic enough_ERROR_REVERSE.md", "name": "UET_generic enough_ERROR_REVERSE.md", "preview": "You\u2019re right to flag this \u2013 I *did* drift back into the error-pipeline as if it were the \u201cmain project,\u201d instead of keeping everything strictly project-agnostic.\n\nLet me cleanly separate what we have so far into three buckets:\n\n---\n\n## 1. What\u2019s already \u201cgeneric enough\u201d (core framework)\n\nThese are structurally fine as **project/module-agnostic templates**. The examples I used were code-centric, but the schemas themselves can be reused anywhere with little or no change:\n\n### \u2705 PROMPT_RENDERING_SPEC (core)\n\n* **Core idea is generic**:\n\n  * A `PromptInstance` JSON with `sections` (HEADER / OBJECT"}
{"path": "specs/UET_meta layer.md", "name": "UET_meta layer.md", "preview": "Perfect, this is a clean place to standardize things.\n\nHere\u2019s a **single, universal \u201cDoc Meta Schema\u201d** we can apply to *every* document in your system. This is the frontmatter that sits at the top of each file and gives the pipeline everything it needs to:\n\n* know **what** the doc is,\n* know **where** it lives in the stack,\n* validate that it\u2019s **safe to use**,\n* and enforce **patch-only, schema-first** changes.\n\nI\u2019ll define:\n\n1. The **fields & semantics** (canonical list).\n2. A **JSON Schema** you can adopt as `schema/doc-meta.v1.json`.\n3. A **frontmatter shape** (not a full doc, just the me"}
{"path": "specs/UET_PATCH_MANAGEMENT_SPEC.md", "name": "UET_PATCH_MANAGEMENT_SPEC.md", "preview": "Good target. Let\u2019s lock down **what PATCH_MANAGEMENT_SPEC actually is** in your stack and define the core data structures + rules, without writing an actual spec file yet.\n\nI\u2019ll treat it just like we did PROMPT_RENDERING_SPEC and TASK_ROUTING_SPEC: **schemas + behaviors + invariants.**\n\n---\n\n## 1. Role & position of PATCH_MANAGEMENT_SPEC\n\n* `doc_type`: `core_spec`\n* `doc_layer`: `framework`\n* It owns the rules and schemas for:\n\n  1. **PatchArtifact** \u2013 the actual unified diff + metadata.\n  2. **PatchLedgerEntry** \u2013 how every patch is logged, validated, and tracked.\n  3. **PatchPolicy** \u2013 const"}
{"path": "specs/UET_PH-ERR-01 + WS-ERR-01A.md", "name": "UET_PH-ERR-01 + WS-ERR-01A.md", "preview": "Here\u2019s a tight \u201cError Pipeline Bundle\u201d design that stays in planning mode and snaps into everything we\u2019ve already defined.\n\nWe\u2019ll define:\n\n* **PH-ERR-01 + WS-ERR-01A** \u2192 intake & repair attempts (what we already sketched).\n* **PH-ERR-02 + WS-ERR-02A** \u2192 escalation & GitHub PR/issue creation.\n* The **chaining** between them via `RunEvent`s and error handling.\n\n---\n\n## 1. Bundle overview (conceptual)\n\nThink of the Error Pipeline Bundle as two phases:\n\n1. **PH-ERR-01 \u2013 Patch Intake & Automated Repair**\n\n   * Workstream: **WS-ERR-01A**\n     \u201cTry to normalize, analyze, and automatically fix a faili"}
{"path": "specs/UET_PHASE_SPEC_MASTER.md", "name": "UET_PHASE_SPEC_MASTER.md", "preview": "Nice, this is where everything starts to snap together.\n\nI\u2019ll keep this as an **outline + structure** for `PHASE_SPEC_MASTER`, and focus on the three key sections you named:\n\n* `files_scope`\n* `constraints`\n* `acceptance`\n\nI\u2019ll also show how each one aligns with:\n\n* `ExecutionRequest.files_scope` / `.constraints`\n* `PatchPolicy`\n* Run `succeeded` in COOPERATION_SPEC.\n\nNo full prose spec, just structure and behavior.\n\n---\n\n## 1. Position & role of PHASE_SPEC_MASTER\n\n**PHASE_SPEC_MASTER** defines the template/schema for all *phase instance* docs like `PH-ERR-01`, `PH-CORE-05`, etc.\n\n* `doc_type`"}
{"path": "specs/UET_PROMPT_RENDERING_SPEC.md", "name": "UET_PROMPT_RENDERING_SPEC.md", "preview": "Nice, this is the fun one.\n\nI\u2019ll treat **PROMPT_RENDERING_SPEC** as a *core spec* that does two things:\n\n1. Defines a **universal prompt object** (JSON) that every prompt must conform to before it\u2019s rendered.\n2. Defines how that object is **rendered to text** for tools like Aider / Codex / Claude.\n\nNo narrative doc, just structure + semantics.\n\n---\n\n## 1. Positioning PROMPT_RENDERING_SPEC in your stack\n\n* `doc_type`: `core_spec`\n* `doc_layer`: `framework`\n* Body of the doc: a machine-readable definition that includes:\n\n  * A **Prompt Instance schema** (what a valid prompt looks like).\n  * A se"}
{"path": "specs/UET_TASK_ROUTING_SPEC.md", "name": "UET_TASK_ROUTING_SPEC.md", "preview": "Short answer: **yes** \u2013 in your world, `TASK_ROUTING_SPEC` should always be phase-aware and treat `PHASE_SPEC_MASTER` as the \u201ccontract of record\u201d for what a task is allowed to do (FILES_SCOPE, CONSTRAINTS, OUTPUT_SPEC, etc.).\n\nBelow I\u2019ll **formalize `TASK_ROUTING_SPEC` as a schema + behavior**, and show exactly how it plugs into:\n\n* `PHASE_SPEC_MASTER` / `phase_spec.schema.json`\n* `PROMPT_RENDERING_SPEC` / `prompt_instance.v1.json`\n\nNo prose spec file, just the **shape and rules**.\n\n---\n\n## 1. Role of `TASK_ROUTING_SPEC` in the stack\n\n**Doc meta (from Doc Meta Schema)**\n\n* `doc_type`: `core_sp"}
{"path": "specs/UET_WORKSTREAM_SPEC.md", "name": "UET_WORKSTREAM_SPEC.md", "preview": "Here\u2019s a clean formalization of **WORKSTREAM_SPEC** that fits with everything we already defined (PHASE_SPEC_MASTER, ExecutionRequest, PromptInstance, Patch, Run, etc.).\n\nStaying in **schema/structure mode only**, no narrative doc.\n\n---\n\n## 1. Role & position of WORKSTREAM_SPEC\n\n**WORKSTREAM_SPEC (core spec)**\n\n* `doc_type`: `core_spec`\n* `doc_layer`: `framework`\n* Owns the schema: `schema/workstream_spec.v1.json`\n\n**Workstream instance docs**\n\n* `doc_type`: `workstream_spec`\n* `doc_layer`: usually `project` or `module`\n* Conform to `workstream_spec.v1.json`\n* Typically named like: `WS-ERR-01A"}
{"path": "specs/UET_WS-ERR-01A.md", "name": "UET_WS-ERR-01A.md", "preview": "Good target for a dry-run. Let\u2019s treat this as a **design rehearsal** for `WS-ERR-01A`, not a final document.\n\nI\u2019ll do three things:\n\n1. Propose an **illustrative WS-ERR-01A** mapped to the `WORKSTREAM_SPEC` schema (focus on `tasks`).\n2. Show how each task maps into **ExecutionRequest / Prompt / Patch / Run**.\n3. Call out any **design tweaks** we might want.\n\n---\n\n## 1. WS-ERR-01A \u2013 illustrative mapping to WORKSTREAM_SPEC\n\nThis is **pseudo-YAML**, meant only as a schema sanity check:\n\n````yaml\nworkstream_id: \"WS-ERR-01A\"\nproject_id: \"PRJ-HUEY_P\"\nphase_id: \"PH-ERR-01\"\n\nname: \"Error Patch Intake"}
{"path": "core/adapters/README.md", "name": "README.md", "preview": "# core/adapters\n\n**Purpose**: Tool integration layer providing uniform interfaces for executing external tools (CLI, API, custom implementations).\n\n## Overview\n\nAdapters provide a consistent execution interface for heterogeneous tools:\n- **Subprocess adapters** - Execute CLI tools (aider, pytest, ruff, git)\n- **API adapters** - Integrate with REST/GraphQL services\n- **Custom adapters** - Domain-specific tool implementations\n\nAll adapters implement the same contract, allowing the engine to treat tools uniformly.\n\n## Key Files\n\n- **`base.py`** - ToolAdapter abstract base class\n- **`registry.py`*"}
{"path": "core/bootstrap/README.md", "name": "README.md", "preview": "# core/bootstrap\n\n**Purpose**: Autonomous project discovery and configuration system that analyzes any project and generates appropriate UET configuration.\n\n## Overview\n\nThe bootstrap module enables UET to automatically configure itself for any project by:\n1. Scanning project structure and detecting technologies\n2. Selecting the best-matching profile\n3. Generating PROJECT_PROFILE.yaml and router_config.json\n4. Validating all generated artifacts\n\n## Key Files\n\n- **`orchestrator.py`** - Main entry point; coordinates entire bootstrap process\n- **`scanner.py`** - Project structure analysis and tec"}
{"path": "core/engine/README.md", "name": "README.md", "preview": "# core/engine\n\n**Purpose**: Task orchestration engine providing scheduling, routing, resilient execution, and real-time monitoring for autonomous workflows.\n\n## Overview\n\nThe engine is the heart of UET, responsible for:\n1. **Routing** - Matching tasks to capable tools\n2. **Scheduling** - Resolving dependencies and creating execution DAGs\n3. **Execution** - Running tasks with fault tolerance\n4. **Monitoring** - Tracking progress and calculating metrics\n\n## Key Files\n\n- **`router.py`** - Routes tasks to appropriate tools based on capabilities\n- **`scheduler.py`** - Dependency resolution and topo"}
{"path": "core/state/README.md", "name": "README.md", "preview": "# core/state\n\n**Purpose**: State management and persistence for execution runs, tasks, and checkpoints.\n\n## Overview\n\nThe state module provides:\n- **Run state tracking** - Track execution runs from start to completion\n- **Task state management** - Monitor individual task status and progress\n- **Checkpoint system** - Time-travel debugging with ULID-based snapshots\n- **Audit trail** - Append-only JSONL logs of all state transitions\n\n## Key Files\n\n- **`db.py`** - SQLite database operations for run/task state\n- **`run_manager.py`** - High-level run state management\n- **`checkpoint.py`** - Checkpoi"}
{"path": "core/engine/monitoring/README.md", "name": "README.md", "preview": "# core/engine/monitoring\n\n**Purpose**: Real-time progress tracking and execution metrics.\n\n## Overview\n\nProvides monitoring capabilities:\n- **Progress Tracking** - Task and run-level progress\n- **Metrics Collection** - Performance statistics\n- **ETA Calculation** - Estimated completion time\n- **Snapshots** - Real-time state snapshots\n\n## Key Files\n\n- **progress.py** - ProgressTracker implementation\n- **metrics.py** - MetricsCollector for statistics\n- **snapshot.py** - State snapshot generation\n\n## Dependencies\n\n**Depends on:**\n- core/state/ - For run/task state\n\n**Used by:**\n- core/engine/ - F"}
{"path": "core/engine/resilience/README.md", "name": "README.md", "preview": "# core/engine/resilience\n\n**Purpose**: Fault tolerance patterns for reliable external tool execution.\n\n## Overview\n\nProvides resilience patterns to handle failures gracefully:\n- **Circuit Breaker** - Prevent cascading failures\n- **Retry with Exponential Backoff** - Handle transient failures\n- **Timeout Management** - Prevent indefinite waiting\n- **Failure Tracking** - Monitor tool reliability\n\n## Key Files\n\n- **circuit_breaker.py** - Circuit breaker implementation\n- **executor.py** - ResilientExecutor with retry logic\n- **backoff.py** - Exponential backoff strategies\n\n## Dependencies\n\n**Depend"}
{"path": "docs/integration/README.md", "name": "README.md", "preview": "# UET Framework Integration Documentation\n\n**Location**: `UNIVERSAL_EXECUTION_TEMPLATES_FRAMEWORK/docs/integration/`  \n**Purpose**: Documentation for integrating UET framework into existing projects  \n**Status**: Planning Complete - Ready for Implementation  \n\n---\n\n## \ud83d\udcda Available Documentation\n\n### Start Here\n- **[UET_INDEX.md](UET_INDEX.md)** - Master documentation index and navigation guide\n- **[UET_QUICK_REFERENCE.md](UET_QUICK_REFERENCE.md)** - Quick commands and troubleshooting (10 min read)\n\n### Complete Integration Plan\n- **[UET_INTEGRATION_DESIGN.md](UET_INTEGRATION_DESIGN.md)** - Full"}
{"path": "docs/integration/UET_INDEX.md", "name": "UET_INDEX.md", "preview": "# UET Framework - Complete Documentation Index\n\n**Universal Execution Templates Integration**  \n**Version**: 1.0  \n**Last Updated**: 2025-11-21\n\n---\n\n## Quick Navigation\n\n### \ud83d\ude80 Get Started\n- **New Users**: Start with [Phase Roadmap](PHASE_ROADMAP.md)\n- **Validate Plans**: `python scripts/validate_plan.py --workstreams-dir workstreams`\n- **View Events**: `python scripts/view_events.py --tail 20`\n\n### \ud83d\udcd6 Core Documentation\n\n#### Implementation Status\n1. **[UET Integration Plan](UET_INTEGRATION_PLAN.md)** - Original 14-week integration strategy\n2. **[UET Implementation Complete](UET_IMPLEMENTATION"}
{"path": "docs/integration/UET_INTEGRATION_DESIGN.md", "name": "UET_INTEGRATION_DESIGN.md", "preview": "# UET Framework Selective Integration - Design Document\n\n**Status**: Active Implementation  \n**Decision**: Option A - Selective Integration  \n**Timeline**: 3-4 weeks  \n**Risk Level**: Low  \n**Created**: 2025-11-22  \n\n---\n\n## Executive Summary\n\nThis document outlines the **selective integration** of the Universal Execution Templates (UET) Framework into the existing AI Development Pipeline. We adopt three high-value components while preserving existing orchestration and state management.\n\n**Adopted Components:**\n1. \u2705 **Bootstrap System** - Auto-project configuration\n2. \u2705 **Resilience Module** -"}
{"path": "docs/integration/UET_QUICK_REFERENCE.md", "name": "UET_QUICK_REFERENCE.md", "preview": "# UET Integration Quick Reference\n\n**Last Updated**: 2025-11-22  \n**Integration Status**: Phase 1 - Foundation (Week 1)  \n**Risk Level**: Low (Additive changes only)  \n\n---\n\n## \ud83d\ude80 Quick Start\n\n### Bootstrap a Project\n\n```bash\n# Bootstrap current project\npython scripts/bootstrap_uet.py .\n\n# Bootstrap specific project\npython scripts/bootstrap_uet.py /path/to/project\n\n# Validate existing artifacts\npython scripts/bootstrap_uet.py --validate-only\n```\n\n### Generated Files\n\nAfter bootstrap, you'll have:\n- `PROJECT_PROFILE.yaml` - Auto-detected project configuration\n- `router_config.json` - Tool routin"}
{"path": "profiles/software-dev-python/README.md", "name": "README.md", "preview": "# Software Development Profile (Python Variant)\n\nThis profile configures the Universal Execution Templates Framework for Python software development projects.\n\n## When to Use This Profile\n\nUse `software-dev-python` when your project:\n- Is primarily Python code (>60% .py files)\n- Has tests (pytest, unittest, etc.)\n- Uses version control (git)\n- Follows software development best practices\n"}
{"path": "2025-11-22-command-messageinit-is-analyzing-your-codebase.txt", "name": "2025-11-22-command-messageinit-is-analyzing-your-codebase.txt", "preview": "\n \u2590\u259b\u2588\u2588\u2588\u259c\u258c   Claude Code v2.0.50\n\u259d\u259c\u2588\u2588\u2588\u2588\u2588\u259b\u2598  Sonnet 4.5 \u00b7 Claude Pro\n  \u2598\u2598 \u259d\u259d    ~\\ALL_AI\\Complete AI Development Pipeline \u2013 Canonical Phase Plan\u2026\n\n> /init is analyzing your codebase\u2026 \n\n\u25cf I'll analyze the codebase to create a comprehensive CLAUDE.md file. Let me\n   start by exploring the repository structure and key documentation.\n\n\u25cf Read(README.md)\n  \u23bf \u00a0Read 360 lines\n\n\u25cf Read(CLAUDE.md)\n  \u23bf \u00a0Error reading file\n\n\u25cf Search(pattern: \"**/*.md\")\n  \u23bf \u00a0Found 0 files \n\n\u25cf Bash(cd \"C:\\Users\\richg\\ALL_AI\\Complete AI Development Pipeline \u2013 Canonical\n      Phase Plan\\UNIVERSAL_EXECUTION_TEMPLATES_FRAMEWORK\" &"}
{"path": "agents and custom commands.txt", "name": "agents and custom commands.txt", "preview": "Yes\u2014based on the plan in those chats/files, there are several parts of the project where **sub-agents are clearly more efficient and safer** than \u201cmore full agents,\u201d and a few places where a single top-level agent is better.\n\nI\u2019ll break it into:\n\n1. How I\u2019m defining **agent vs sub-agent** in *your* ecosystem\n2. Where **sub-agents are the better fit** (concrete parts of your plan)\n3. Where a **single strong agent** is actually better\n4. A tiny example graph that matches your UET / Phase / Workstream world\n\n---\n\n## 1. Agent vs sub-agent in your setup\n\nGiven your UET + Phase Spec + Workstream mod"}
{"path": "cladueplan.txt", "name": "cladueplan.txt", "preview": "\n \u2590\u259b\u2588\u2588\u2588\u259c\u258c   Claude Code v2.0.50\n\u259d\u259c\u2588\u2588\u2588\u2588\u2588\u259b\u2598  Sonnet 4.5 \u00b7 Claude Pro\n  \u2598\u2598 \u259d\u259d    ~\\ALL_AI\\Complete AI Development Pipeline \u2013 Canonical Phase Plan\u2026\n\n> \"C:\\Users\\richg\\ALL_AI\\Complete AI Development Pipeline \u2013 Canonical Phase \nPlan\\UNIVERSAL_EXECUTION_TEMPLATES_FRAMEWORK\\claude chat.txt\"\n\"C:\\Users\\richg\\ALL_AI\\Complete AI Development Pipeline \u2013 Canonical Phase \nPlan\\UNIVERSAL_EXECUTION_TEMPLATES_FRAMEWORK\\CLAUDE_CHAT_UTE.txt\"\n\"C:\\Users\\richg\\ALL_AI\\Complete AI Development Pipeline \u2013 Canonical Phase \nPlan\\UNIVERSAL_EXECUTION_TEMPLATES_FRAMEWORK\\chat 2.md\" \n\n\u25cf I'll read these chat/conversation files "}
{"path": "claude chat.txt", "name": "claude chat.txt", "preview": "Core Principles\nExplicit hierarchy with clear boundaries. AI tools navigate by understanding scope and relationships. Your directory structure should make dependencies flow in one direction\u2014typically from generic/foundational at the root toward specific/application at the leaves. When AI sees core/, services/, api/, cli/ it immediately understands architectural layers without reading any code.\nSelf-documenting organization. Every directory should have a single, clear purpose that's obvious from its name. Avoid clever abstractions or overly generic names like utils/, helpers/, or misc/. Instead"}
{"path": "three instruction docs for cli tools.txt", "name": "three instruction docs for cli tools.txt", "preview": "\nBelow are **three instruction docs**:\n\n* `CLAUDE.md` \u2013 for Claude Code CLI\n* `.github/copilot-instructions.md` \u2013 for GitHub Copilot\n* `AGENTS.md` \u2013 for Codex / agentic CLI\n\nAll three **assume** you have a shared core doc at `docs/DEV_RULES_CORE.md` that contains the full UET framework (Phase/Workstream, Patch, Kernel, Tool Execution, etc.).\n\n---\n\n## 1) `CLAUDE.md` \u2013 Claude Code CLI instructions\n\n```markdown\n# CLAUDE.md \u2013 Claude Code CLI Instructions\n\n## 0. Role and Scope\n\nYou are **Claude Code CLI** working inside a spec-governed pipeline.\n\nYour primary job in this repository is to:\n\n- Implem"}
{"path": "UET_LI Tool Execution Specification.txt", "name": "UET_LI Tool Execution Specification.txt", "preview": "---\nmeta_version: \"doc-meta.v1\"\ndoc_ulid: \"01JAAAAAAA0CLI0TOOLEXEC0001\"\ndoc_type: \"core_spec\"\ndoc_layer: \"framework\"\ntitle: \"CLI Tool Execution Specification\"\nsummary: \"Defines how a single CLI instance (e.g. Claude Code CLI, GitHub Copilot CLI) executes tasks from multiple workstreams using queues, workers, and sandboxes.\"\nversion: \"1.0.0\"\nstatus: \"draft\"\nschema_ref: \"schema/tool_execution_profile.v1.json\"\ncreated_at: \"2025-11-22T00:00:00Z\"\nupdated_at: \"2025-11-22T00:00:00Z\"\nauthor_type: \"mixed\"\nowner: \"SYSTEM:AGENT_ORCHESTRATOR\"\nsecurity_tier: \"internal\"\n\nproject_id: null\nmodule_id: null\npha"}
