# .ai-module-manifest
# AI-readable module specification for error.engine

module: "error.engine"
purpose: "Error detection engine: plugin orchestration, result aggregation, reporting"
layer: "domain"  # Domain layer - business logic

# Entry points
entry_points:
  - file: "error_engine.py"
    class: "ErrorEngine"
    function: "__init__()"
    description: "Initialize engine, auto-discover plugins"
    
  - file: "error_engine.py"
    class: "ErrorEngine"
    function: "scan(path: str)"
    description: "Scan path with all enabled plugins"
    
  - file: "error_engine.py"
    class: "ErrorEngine"
    function: "report(format: str = 'text')"
    description: "Generate formatted error report"
    
  - command: "python -m error.engine --scan <path>"
    description: "CLI entry point"

# Key patterns
key_patterns:
  - "Plugin discovery on initialization (scans error/plugins/)"
  - "Each plugin runs independently (no shared state)"
  - "Results aggregated into single error list"
  - "Errors can be filtered, sorted, formatted"
  - "Database logging optional (via --log-to-db flag)"
  - "Exit code 0 if no errors, 1 if errors found"

# Architecture
architecture:
  flow: |
    ErrorEngine.__init__()
      ├─ Discover plugins from error/plugins/
      ├─ Load plugin configuration
      └─ Initialize plugin instances
    
    ErrorEngine.scan(path)
      ├─ Walk directory tree
      ├─ For each file:
      │   ├─ Determine applicable plugins
      │   ├─ Run plugin.parse(file)
      │   └─ Collect errors
      ├─ Aggregate all errors
      └─ Return List[Error]
    
    ErrorEngine.report(format)
      ├─ Format errors (json/text/github)
      └─ Return formatted string
      
  components:
    error_engine:
      responsibility: "Orchestrate plugin execution"
      
    plugin_loader:
      responsibility: "Discover and load plugins"
      
    error_formatter:
      responsibility: "Format errors for output"

# Common tasks
common_tasks:
  - task: "Scan and get errors"
    code: |
      from error.engine.error_engine import ErrorEngine
      engine = ErrorEngine()
      errors = engine.scan("path/to/code")
      
  - task: "Generate JSON report"
    code: |
      engine = ErrorEngine()
      engine.scan(".")
      json_report = engine.report(format="json")
      
  - task: "Scan with specific plugins only"
    code: |
      engine = ErrorEngine(plugins=["python_ruff"])
      errors = engine.scan(".")
      
  - task: "Filter errors by severity"
    code: |
      errors = engine.scan(".")
      critical = [e for e in errors if e.severity == "error"]

# Plugin discovery
plugin_discovery:
  mechanism: "Directory scanning"
  location: "error/plugins/"
  requirements:
    - "Directory name = plugin name"
    - "Contains plugin.py file"
    - "plugin.py exports parse() function or Plugin class"
    
  discovery_order:
    1: "Scan error/plugins/ for subdirectories"
    2: "Check each for plugin.py"
    3: "Import plugin module"
    4: "Instantiate if class, use directly if function"
    5: "Register in engine._plugins dict"

# Error aggregation
error_aggregation:
  deduplication: "Same file+line+type = single error"
  sorting: "By file, then line, then column"
  filtering: "By language, type, severity"
  
# Gotchas
gotchas:
  - "Plugin failures are caught and logged, don't stop engine"
  - "File walking respects .gitignore patterns"
  - "Large codebases can take minutes (no caching)"
  - "Plugins must handle binary files gracefully"
  - "Error.file paths normalized to absolute"
  - "Plugin order is non-deterministic (dict iteration)"

# Deprecated
deprecated:
  - old: "MOD_ERROR_PIPELINE.error_engine"
    new: "error.engine.error_engine"
    reason: "Section-based refactor (2025-11-20)"

# Dependencies
dependencies:
  external:
    - pathlib
    - typing
    - json
    - logging
    
  internal:
    - error.plugins.*  # All plugins
    - core.state.crud  # Optional database logging

# CLI interface
cli_interface:
  usage: "python -m error.engine [OPTIONS]"
  options:
    - "--scan PATH": "Scan directory or file"
    - "--format {json,text,github}": "Output format (default: text)"
    - "--log-to-db": "Log errors to database"
    - "--plugins PLUGIN1,PLUGIN2": "Only run specified plugins"
    - "--severity {error,warning,info}": "Filter by minimum severity"
    - "--language LANG": "Only scan files of language"
    
  examples: |
    # Scan current directory
    python -m error.engine --scan .
    
    # JSON output
    python -m error.engine --scan . --format=json
    
    # Only Python errors
    python -m error.engine --scan . --language=python
    
    # Critical errors only
    python -m error.engine --scan . --severity=error

# Test files
test_files:
  - "tests/error/engine/test_error_engine.py"
  - "tests/error/engine/test_plugin_discovery.py"
  - "tests/error/engine/test_error_formatting.py"

# Documentation
documentation:
  - "error/engine/README.md"
  - "error/README.md"
  - "docs/plugin-ecosystem-summary.md"

# Status
status:
  maturity: "beta"
  test_coverage: "~70%"
  production_ready: false
  last_major_change: "2025-11-20 (section-based refactor)"

# AI quick reference
ai_quick_reference:
  basic_scan: "from error.engine.error_engine import ErrorEngine; errors = ErrorEngine().scan('.')"
  with_format: "engine = ErrorEngine(); engine.scan('.'); print(engine.report(format='json'))"
  cli: "python -m error.engine --scan . --format=json"

# Performance
performance:
  bottlenecks:
    - "File I/O (reading all files)"
    - "External process calls (e.g., ruff)"
    - "Large file parsing (AST analysis)"
    
  optimization_opportunities:
    - "Parallel plugin execution"
    - "File content caching"
    - "Incremental scanning (changed files only)"
    - "Skip binary files early"

# Error handling
error_handling:
  plugin_errors: "Caught and logged, don't stop execution"
  file_errors: "Skipped with warning logged"
  invalid_paths: "Raises FileNotFoundError"
  
# Recent changes
recent_changes:
  - date: "2025-11-20"
    change: "Refactored from MOD_ERROR_PIPELINE"
    impact: "Import paths changed"
    
  - date: "2025-11-19"
    change: "Added GitHub Actions output format"
    impact: "Better CI integration"
    
  - date: "2025-11-18"
    change: "Improved plugin discovery robustness"
    impact: "Handles missing/broken plugins gracefully"

# Related modules
related_modules:
  - module: "error.plugins"
    relationship: "Provides detection plugins"
    
  - module: "core.state"
    relationship: "Optional error logging to database"

# For AI tools
for_ai_tools:
  when_to_suggest: |
    User mentions: lint, validate, check, analyze, detect errors
    Suggest: python -m error.engine --scan <path>
    
  typical_workflow: |
    1. User makes code changes
    2. Run error detection: python -m error.engine --scan .
    3. Review errors
    4. Fix issues
    5. Re-run to verify
