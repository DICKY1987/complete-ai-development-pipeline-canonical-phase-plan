TITLE: PH-04.5 – Git Worktree Lifecycle Management (Codex Autonomous Phase Executor)

ROLE
You are Codex running with full access to a Windows development environment using PowerShell and Git.
Your job is to COMPLETELY IMPLEMENT phase PH-04.5 (Git Worktree Lifecycle Management) for the AI Development Pipeline project, end-to-end, without requiring further user input.

You will:
- Implement a safe, deterministic git worktree lifecycle for per-workstream isolation.
- Provide Python APIs in worktree.py for creating, inspecting, validating, and cleaning worktrees.
- Enforce file-scope rules (only allowed files changed).
- Provide CLI scripts for operators/AI agents to manage worktrees.
- Add tests and docs so later phases (PH-05, PH-06, PH-06.5, PH-07a/b) can rely on this.

OPERATING CONTEXT
- OS: Windows 10/11
- Shell: PowerShell 7+ (pwsh)
- Version control: git (worktree support)
- Orchestrator language: Python 3.12+
- Previous phases:
  - PH-00: baseline project skeleton (src/pipeline/, tests/, docs/, scripts/, CI).
  - PH-01: spec index & module stubs (src/pipeline/worktree.py already exists as a stub).
  - PH-02: SQLite DB + state machine (db.py).
  - PH-03: tool adapter (tools.py).
  - PH-03.5: Aider integration & prompt engine.
  - PH-04: workstream bundle parsing & validation (bundles.py, workstreams/, DAG).

PROJECT ROOT (IMPORTANT)
- Expected project root: C:\Users\richg\ALL_AI\AI_Dev_Pipeline

If that folder does NOT exist:
- Stop and write a clear, prominent note into docs/PHASE_PLAN.md under PH-04.5 that PH-00–PH-04 must be completed first.
- Do NOT attempt to set up git worktrees somewhere else.

If it DOES exist:
- cd into that folder and proceed.

====================================
HIGH-LEVEL GOAL OF PH-04.5
====================================

Provide **safe, per-workstream git worktrees** with:

1) A standard layout under .worktrees/<ws-id>/.
2) Deterministic branch naming and base branch selection.
3) Pre-flight safety checks (base repo clean, base branch exists).
4) Post-step validation that only allowed files changed (files_scope + files_create).
5) Discovery and cleanup of orphaned worktrees.
6) Simple CLI commands for init/list/status/cleanup.

This is the git-safety backbone for PH-05 (orchestrator), PH-06 (circuit breakers + FIX loop), and PH-06.5 (recovery).

You are NOT implementing the orchestrator loop yet; you are building the worktree subsystem it will call.

====================================
REQUIRED OUTPUTS OF THIS PHASE
====================================

By the end of PH-04.5, the repo MUST have at minimum:

1) STANDARD WORKTREE LAYOUT & NAMING
- Worktrees MUST live under:
  - <PROJECT_ROOT>/.worktrees/<ws-id>/
- Branch naming convention:
  - ws/<run-id>/<ws-id>
  - Example:
    - run_id: RUN-2025-01
    - ws_id: ws-parser-refactor
    - branch: ws/RUN-2025-01/ws-parser-refactor

- Base branch:
  - Configurable, default "main".
  - Resolved from (in order):
    1) PIPELINE_BASE_BRANCH env var
    2) config/base_branch.txt (if present)
    3) Fallback: "main"

2) worktree.py – WORKTREE LIFECYCLE MODULE
Implement src/pipeline/worktree.py with at least the following:

Core types & helpers:

- A WorktreeInfo dataclass (or typed dict) with:
  - ws_id: str
  - run_id: str | None
  - path: pathlib.Path
  - branch: str
  - base_branch: str
  - exists: bool
  - clean: bool          # no uncommitted changes
  - last_commit: str | None
  - status_summary: str  # short human-readable status

- Helper functions:

  1) get_repo_root() -> Path
     - Returns the git repo root (directory containing .git).
     - Assumes project root is a git repo.
     - If it cannot find .git, raise a clear error.

  2) get_worktree_root() -> Path
     - Returns <repo_root>/.worktrees
     - Ensures the directory exists (create with parents=True, exist_ok=True).

  3) get_base_branch() -> str
     - Determine base branch using the rules above.
     - Must verify that the branch actually exists (via git).
     - If not, raise a clear, actionable error.

Worktree lifecycle functions:

  4) compute_worktree_path(ws_id: str) -> Path
     - Returns <repo_root>/.worktrees/<ws-id>

  5) compute_worktree_branch(run_id: str | None, ws_id: str) -> str
     - Implements ws/<run-id>/<ws-id> naming.
     - If run_id is None, fall back to ws/<ws-id>.

  6) ensure_base_repo_clean() -> None
     - From repo_root:
       - Run `git status --porcelain`.
       - If any uncommitted changes, raise an error.
       - This is to protect from accidentally creating worktrees from dirty base.

  7) create_worktree_for_ws(run_id: str, ws_id: str) -> WorktreeInfo
     - Steps:
       - Determine repo_root, worktree_root, base_branch.
       - Run ensure_base_repo_clean().
       - Compute worktree_path and branch name.
       - If worktree_path already exists:
         - Option 1: Treat as existing worktree (inspect & return info).
         - Option 2: Fail fast with clear message.
         - For v1, you may choose to fail unless explicitly told otherwise; document the behavior.
       - Use git worktree to create:
         - git worktree add -B <branch> <worktree_path> <base_branch>
       - Return WorktreeInfo populated with metadata.

  8) get_worktree_info(ws_id: str, run_id: str | None = None) -> WorktreeInfo
     - Fill in:
       - path, branch, base_branch, exists (path + git worktree metadata).
       - clean (no uncommitted changes in that worktree).
       - last_commit (git rev-parse HEAD).
       - status_summary (short string used by CLI).

  9) list_worktrees() -> list[WorktreeInfo]
     - Inspect `git worktree list --porcelain` OR parse `.git/worktrees` to detect worktrees.
     - Build WorktreeInfo for each that lives under .worktrees/ (ignore others).
     - Useful for CLI “list/status” commands.

  10) remove_worktree(ws_id: str, *, force: bool = False) -> None
      - Steps:
        - Get worktree_path / branch.
        - Run (safe default):
          - git worktree remove <worktree_path>
        - If force=True, use:
          - git worktree remove --force <worktree_path>
        - Optionally delete branch:
          - git branch -D <branch> (if branch exists and no longer needed).
        - Must not affect remote branches or non-worktree branches.

Scope enforcement & validation:

  11) validate_scope(ws_id: str, files_scope: list[str], files_create: list[str] | None = None) -> dict
      - Purpose:
        - Ensure that the changes in this worktree are limited to:
          - files_scope, and
          - files_create (allowed new files).
      - Steps:
        - From worktree path:
          - Run git diff --name-status <base_branch>..HEAD
          - Parse output to get file paths and statuses (A/M/D/R/etc).
        - Determine:
          - changed_files = set of paths that were touched.
          - created_files = subset with status "A".
        - Compute:
          - out_of_scope_files = changed_files - (files_scope ∪ files_create)
        - Return a dict:
          {
            "changed_files": [...],
            "created_files": [...],
            "out_of_scope_files": [...],
            "ok": bool  # True if out_of_scope_files is empty
          }
      - Later phases (PH-05/PH-06) will:
        - Treat any non-empty out_of_scope_files as a failed workstream and log it.

Orphan detection & cleanup:

  12) find_orphan_worktrees(known_ws_ids: set[str]) -> list[WorktreeInfo]
      - Find all worktrees under .worktrees/.
      - For each:
        - If its ws_id is NOT in known_ws_ids (e.g., from DB/workstreams table):
          - Mark as orphan.
      - Return list of orphan WorktreeInfo objects.

  13) cleanup_orphan_worktrees(known_ws_ids: set[str], *, force: bool = False) -> list[WorktreeInfo]
      - Calls find_orphan_worktrees(...) and remove_worktree() for each.
      - Returns list of cleaned-up worktrees.

3) CLI SCRIPTS FOR WORKTREE MANAGEMENT
Add Python-based CLI in scripts, plus (optional) PowerShell wrappers.

Python CLI:

- scripts/worktrees.py
  - Must be runnable as:
    - python scripts/worktrees.py <subcommand> [options]

  - Subcommands:

    1) init
       - Args:
         - --run-id RUN_ID
         - --ws-id WS_ID
       - Behavior:
         - Calls create_worktree_for_ws(run_id, ws_id).
         - Prints:
           - Path
           - Branch
           - Base branch

    2) list
       - Behavior:
         - Calls list_worktrees().
         - Prints table:
           - ws_id, run_id (if derivable from branch name), path, branch, clean?, last_commit.

    3) status
       - Args:
         - --ws-id WS_ID
       - Behavior:
         - Calls get_worktree_info(ws_id).
         - Prints detailed status.

    4) validate-scope
       - Args:
         - --ws-id WS_ID
         - --files-scope FILE (comma-separated list or JSON file path)
         - --files-create FILE (optional)
       - Behavior:
         - Loads scope from CLI or JSON file.
         - Calls validate_scope(ws_id, files_scope, files_create).
         - Prints summary and exits with:
           - 0 if ok=True.
           - non-zero if out_of_scope_files not empty.

    5) cleanup-orphans
       - Args:
         - --known-ws-file PATH (JSON/YAML list of known ws_ids) OR simple CSV/JSON.
         - --force (optional)
       - Behavior:
         - Reads known_ws_ids from the file.
         - Calls cleanup_orphan_worktrees(...).
         - Prints list of removed worktrees.

PowerShell wrappers (optional but helpful):

- scripts/Worktrees.ps1
  - Provide thin wrappers around the Python CLI for:
    - Worktrees-Init
    - Worktrees-List
    - Worktrees-Status
    - Worktrees-ValidateScope
    - Worktrees-CleanupOrphans

4) UNIT TESTS
- tests/pipeline/test_worktree.py
  - These tests should:
    - Use a temp git repo rather than the real project repo.
      - Setup steps:
        - Create temp dir.
        - Run git init.
        - Create one or two files and commit.
      - For tests requiring base_branch, create a "main" branch.
    - Use worktree functions against this temp repo.

  - Test cases:

    1) get_repo_root() finds the .git directory.
    2) get_worktree_root() creates .worktrees/ under repo root.
    3) get_base_branch() returns correct branch and errors if missing.
    4) create_worktree_for_ws():
       - Creates directory under .worktrees/<ws-id>.
       - Creates branch ws/<run-id>/<ws-id>.
       - Fails if base repo is dirty.
    5) list_worktrees() returns at least one instance after creation.
    6) get_worktree_info() correctly reports clean/dirty state:
       - Make a change in worktree; ensure clean=False.
    7) validate_scope():
       - Make changes to a file in allowed files_scope → ok=True.
       - Make changes to a file outside scope → ok=False, out_of_scope_files contains that file.
    8) find_orphan_worktrees():
       - When known_ws_ids does NOT include a worktree's ws_id, it is reported as orphan.
    9) cleanup_orphan_worktrees():
       - Actually removes orphan worktrees and returns them.

  - If needed, you can add small helper functions inside tests to create commits and branches.

5) DOCUMENTATION UPDATES
- docs/ARCHITECTURE.md:
  - Add a section “Git Worktree Lifecycle & Scope Enforcement”.
  - Describe:
    - Worktree location .worktrees/<ws-id>.
    - Branch naming pattern ws/<run-id>/<ws-id>.
    - How this interacts with:
      - Aider (PH-03.5).
      - Scope enforcement using validate_scope().
    - The role of scripts/worktrees.py and (optionally) scripts/Worktrees.ps1.

- docs/PHASE_PLAN.md:
  - Flesh out PH-04.5 section with:
    - Summary of capabilities.
    - List of new artifacts:
      - src/pipeline/worktree.py
      - scripts/worktrees.py
      - tests/pipeline/test_worktree.py
    - Explicit note that later phases (PH-05/PH-06) must call create_worktree_for_ws() and validate_scope() at appropriate points.

6) GIT COMMIT
- Stage all new/modified files.
- Commit with message:
  - "PH-04.5: git worktree lifecycle management"
- Do NOT push (remote management is out of scope).

====================================
CONSTRAINTS & PRINCIPLES
====================================

- Do NOT break or remove outputs from PH-00–PH-04; extend them only.
- Do NOT operate directly on remote branches; keep everything local.
- Avoid destructive actions by default:
  - remove_worktree(..., force=False) should be conservative.
  - cleanup_orphan_worktrees should clearly log what it removes.
- Assume that orchestrator and tests will run **from the repo root**, not from arbitrary child directories; design APIs accordingly.
- Make error messages explicit and operator-friendly (mention worktree path, branch, and ws_id).

Implementation details:

- Use Python standard library: subprocess, pathlib, os, typing, dataclasses, json, etc.
- For subprocess:
  - Use subprocess.run() with check=False.
  - Capture stdout/stderr for debugging.
- For tests:
  - Do NOT require internet.
  - Do NOT depend on external repos; create local temp repos.

====================================
EXECUTION PLAN (WHAT YOU SHOULD DO)
====================================

You should:

1) PRECHECKS & NAVIGATION
   - Confirm C:\Users\richg\ALL_AI\AI_Dev_Pipeline exists.
   - cd C:\Users\richg\ALL_AI\AI_Dev_Pipeline
   - Confirm src/pipeline/, docs/, scripts/ exist; if not, create them and note in docs/PHASE_PLAN.md that earlier phases may be partially missing.

2) IMPLEMENT worktree.py
   - Open src/pipeline/worktree.py (stub from PH-01).
   - Implement:
     - get_repo_root(), get_worktree_root(), get_base_branch()
     - compute_worktree_path(), compute_worktree_branch()
     - ensure_base_repo_clean()
     - create_worktree_for_ws()
     - get_worktree_info(), list_worktrees()
     - remove_worktree()
     - validate_scope()
     - find_orphan_worktrees(), cleanup_orphan_worktrees()
   - Add module docstring describing responsibilities and relation to other modules.

3) IMPLEMENT CLI SCRIPT
   - Create scripts/worktrees.py.
   - Use argparse or click (if already in requirements; otherwise prefer argparse).
   - Add subcommands:
     - init, list, status, validate-scope, cleanup-orphans.
   - Make sure script prints informative messages and returns non-zero exit code on validation failure.

4) (OPTIONAL) POWERSHELL WRAPPER
   - Create scripts/Worktrees.ps1.
   - Implement thin wrappers around python scripts/worktrees.py.

5) ADD TESTS
   - Implement tests/pipeline/test_worktree.py.
   - Use pytest fixtures to:
     - Create a temporary git repo.
     - Set working directory for each test.
   - Cover the behaviors listed above.

6) RUN TESTS
   - From project root:
     - Run: pytest
   - Fix any failing tests before considering the phase complete.

7) UPDATE DOCS
   - Update docs/ARCHITECTURE.md with the “Git Worktree Lifecycle & Scope Enforcement” section.
   - Update docs/PHASE_PLAN.md PH-04.5 section.

8) GIT COMMIT
   - Stage and commit with message:
     - "PH-04.5: git worktree lifecycle management"

====================================
PHASE COMPLETION CHECKLIST
====================================

Before you consider PH-04.5 done, ensure all of the following are true:

[ ] src/pipeline/worktree.py implements:
    - get_repo_root(), get_worktree_root(), get_base_branch()
    - compute_worktree_path(), compute_worktree_branch()
    - ensure_base_repo_clean()
    - create_worktree_for_ws()
    - get_worktree_info(), list_worktrees()
    - remove_worktree()
    - validate_scope()
    - find_orphan_worktrees(), cleanup_orphan_worktrees()
[ ] Worktrees are created under .worktrees/<ws-id> with branch naming ws/<run-id>/<ws-id>
[ ] validate_scope() correctly reports out-of-scope changes
[ ] scripts/worktrees.py exists and supports:
    - init, list, status, validate-scope, cleanup-orphans
[ ] tests/pipeline/test_worktree.py exists and passes
[ ] docs/ARCHITECTURE.md has a “Git Worktree Lifecycle & Scope Enforcement” section
[ ] docs/PHASE_PLAN.md has an updated PH-04.5 section listing artifacts and behavior
[ ] A git commit with message like "PH-04.5: git worktree lifecycle management" has been created

====================================
INTERACTION STYLE
====================================

- Do NOT ask the user questions unless you are completely blocked.
- Make reasonable assumptions and document them in:
  - src/pipeline/worktree.py docstrings,
  - docs/ARCHITECTURE.md,
  - docs/PHASE_PLAN.md (PH-04.5 section).
- When you output your response, clearly separate:
  - PowerShell commands you would run.
  - Python and Markdown file contents you would create or modify.

END OF PROMPT
