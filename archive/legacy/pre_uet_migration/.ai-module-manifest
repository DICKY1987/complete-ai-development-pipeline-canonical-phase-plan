# .ai-module-manifest
# AI-readable module specification for core.engine

module: "core.engine"
purpose: "Workstream orchestration: scheduler, executor, task management"
layer: "domain"  # Domain layer - core business logic

# Entry points
entry_points:
  - file: "scheduler.py"
    class: "Scheduler"
    function: "schedule(workstreams: List[Dict])"
    description: "Build execution schedule from workstreams with dependency resolution"
    
  - file: "executor.py"
    class: "Executor"
    function: "execute_step(step: Dict)"
    description: "Execute a single workstream step, handle retries and errors"
    
  - file: "orchestrator.py"
    class: "Orchestrator"
    function: "run_plan(plan_path: str)"
    description: "Main entry point - orchestrate entire workstream execution"
    note: "This is THE primary entry point for workstream execution"

# Key patterns
key_patterns:
  - "Orchestrator delegates to Scheduler for planning, Executor for execution"
  - "Scheduler builds DAG-based execution order using core.state.dag_utils"
  - "Executor handles retries with exponential backoff (max 3 attempts)"
  - "Tool adapters are imported dynamically based on step.action"
  - "State mutations go through core.state.crud (not direct DB access)"
  - "Circuit breaker pattern prevents cascading failures"
  - "All errors logged to core.state errors table"

# Common tasks
common_tasks:
  - task: "Run a workstream plan"
    steps:
      - "from core.orchestrator import Orchestrator"
      - "orch = Orchestrator(db_path='.worktrees/run-001/pipeline.db')"
      - "result = orch.run_plan('workstreams/my_plan.json')"
      
  - task: "Add custom tool adapter"
    steps:
      - "Create adapter in aim/ or pm/ following adapter interface"
      - "Register in router_config.json"
      - "Executor will auto-discover based on step.action"
      
  - task: "Handle execution errors"
    steps:
      - "Errors are caught in executor.py:execute_step()"
      - "Logged to errors table via crud.create_error()"
      - "Step status set to 'failed'"
      - "Retry logic applies if transient error"
      
  - task: "Add new scheduling strategy"
    steps:
      - "Extend scheduler.py:Scheduler class"
      - "Override schedule() method"
      - "Maintain DAG validation (required)"

# Gotchas
gotchas:
  - "Orchestrator is NOT thread-safe (use one instance per run)"
  - "Scheduler.schedule() modifies dependency graph in-place"
  - "Executor retries are synchronous (no async/await yet)"
  - "Tool adapters must be importable (check PYTHONPATH)"
  - "Circuit breaker opens after 5 consecutive failures"
  - "Database connection must be initialized before execution"
  - "Step IDs must be unique within a workstream"

# Deprecated
deprecated:
  - old: "src.pipeline.orchestrator"
    new: "core.orchestrator"
    reason: "Section-based refactor (2025-11-20)"
    
  - old: "src.pipeline.executor"
    new: "core.engine.executor"
    reason: "Section-based refactor (2025-11-20)"

# Dependencies
dependencies:
  external:
    - time      # Sleep for retries
    - logging   # Execution logging
    - typing    # Type hints
    
  internal:
    - core.state.db           # Database initialization
    - core.state.crud         # State mutations
    - core.state.bundle_loader # Workstream loading
    - core.state.dag_utils    # DAG validation
    - aim.bridge              # Tool adapters (optional)
    - pm.bridge               # Project management (optional)
    
  optional:
    - aim.*  # AI tool adapters
    - pm.*   # Project management integrations

# Architecture
architecture:
  flow: |
    Orchestrator.run_plan()
      ├─ Load bundle via core.state.bundle_loader
      ├─ Create run via core.state.crud
      ├─ Scheduler.schedule() → Execution order
      │   └─ DAG validation (cycles check)
      ├─ For each step in order:
      │   └─ Executor.execute_step()
      │       ├─ Lookup tool adapter
      │       ├─ Execute with retry logic
      │       ├─ Update step status
      │       └─ Log errors if any
      └─ Return execution result
      
  components:
    orchestrator:
      responsibility: "High-level workflow coordination"
      dependencies: [scheduler, executor, core.state]
      
    scheduler:
      responsibility: "Build execution schedule from DAG"
      dependencies: [core.state.dag_utils]
      
    executor:
      responsibility: "Execute individual steps with retry/error handling"
      dependencies: [tool_adapters, core.state.crud]

# Tool adapter interface
tool_adapter_interface:
  description: "Tool adapters must implement this interface"
  required_methods:
    - "execute(step: Dict) -> Dict"
  optional_methods:
    - "validate(step: Dict) -> bool"
    - "cleanup() -> None"
  example: |
    class MyToolAdapter:
        def execute(self, step: Dict) -> Dict:
            # Perform action
            return {"status": "success", "result": data}
        
        def validate(self, step: Dict) -> bool:
            # Validate step config
            return True

# Retry logic
retry_logic:
  max_attempts: 3
  backoff: "exponential"
  initial_delay: 1  # seconds
  max_delay: 60     # seconds
  retryable_errors:
    - "NetworkError"
    - "ToolUnavailableError"
    - "TransientDatabaseError"
  non_retryable_errors:
    - "ValidationError"
    - "ConfigurationError"
    - "PermissionError"

# Test files
test_files:
  - "tests/core/engine/test_orchestrator.py"
  - "tests/core/engine/test_scheduler.py"
  - "tests/core/engine/test_executor.py"
  - "tests/integration/test_end_to_end.py"

# Documentation
documentation:
  - "core/engine/README.md"
  - "docs/ARCHITECTURE.md (Orchestration section)"
  - "EXECUTION_INDEX.md (Orchestrator flow)"

# Status
status:
  maturity: "stable"
  test_coverage: "~75%"
  production_ready: true
  last_major_change: "2025-11-20 (section-based refactor)"

# AI quick reference
ai_quick_reference:
  run_workstream: "from core.orchestrator import Orchestrator; orch = Orchestrator(); orch.run_plan('plan.json')"
  schedule_only: "from core.engine.scheduler import Scheduler; sched = Scheduler(); order = sched.schedule(workstreams)"
  execute_step: "from core.engine.executor import Executor; exec = Executor(); result = exec.execute_step(step)"

# Performance considerations
performance:
  - "Scheduler: O(V+E) for topological sort"
  - "Executor: Sequential (no parallelism yet)"
  - "Database: Batch updates recommended for large runs"
  - "Tool adapters: Can be bottleneck (external process calls)"

# Recent changes
recent_changes:
  - date: "2025-11-20"
    change: "Refactored from src.pipeline to core.engine"
    impact: "Import paths changed"
    
  - date: "2025-11-18"
    change: "Added circuit breaker pattern to executor"
    impact: "Prevents cascading failures"
    
  - date: "2025-11-16"
    change: "Improved retry logic with exponential backoff"
    impact: "Better handling of transient errors"

# Related modules
related_modules:
  - module: "core.state"
    relationship: "Depends on for persistence"
    
  - module: "aim"
    relationship: "Uses tool adapters"
    
  - module: "pm"
    relationship: "Uses project management integrations"
