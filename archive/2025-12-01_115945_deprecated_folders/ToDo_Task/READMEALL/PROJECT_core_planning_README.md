---
doc_id: DOC-GUIDE-PROJECT-CORE-PLANNING-README-1580
---

# Core Planning Utilities

> **Module**: `core.planning`  
> **Purpose**: Workstream planning, generation, and archive operations  
> **Layer**: Planning/Utilities  
> **Status**: Beta (Stub for automated planning)

---

## Overview

The `core/planning/` module provides utilities for workstream lifecycle management:

- **Workstream generation** - Automated planning from OpenSpec/CCPM sources (future v2.0)
- **Archive operations** - Package completed workstreams for analysis
- **CCPM integration** - Bridge between project management and workstream execution
- **Parallelism detection** - Identify parallel execution opportunities

This module is currently in **stub mode** for automated planning. Manual workstream authoring is the primary workflow (see `workstreams/` for examples).

---

## Directory Structure

```
core/planning/
‚îú‚îÄ‚îÄ planner.py               # Automated workstream planning (stub)
‚îú‚îÄ‚îÄ archive.py               # Archive completed workstreams
‚îú‚îÄ‚îÄ ccpm_integration.py      # CCPM bridge (tasks ‚Üí workstreams)
‚îî‚îÄ‚îÄ parallelism_detector.py  # Detect parallel opportunities
```

---

## Key Components

### Automated Planner (`planner.py`)

**Status**: üöß **Stub** - Placeholder for future automation

```python
from core.planning.planner import plan_workstreams_from_spec

# Generate draft workstream bundles (stub implementation)
draft_bundles = plan_workstreams_from_spec(
    spec_source="openspec/specs/OS-AUTH-001.yaml",
    options={
        "max_workstreams": 10,
        "group_by": "language",
        "decomposition_strategy": "file"
    }
)

# Returns placeholder bundles for human review
# [
#     {
#         "id": "ws-generated-placeholder",
#         "openspec_change": "OS-GENERATED-001",
#         "ccpm_issue": 999,
#         "gate": 1,
#         "files_scope": ["src/placeholder.py"],
#         "tasks": ["Implement generated placeholder logic."],
#         "tool": "aider",
#         "metadata": {"notes": "Generated by planner stub"}
#     }
# ]
```

**Planned Features** (v2.0):
- Parse OpenSpec change proposals
- Apply decomposition rules from `config/decomposition_rules.yaml`
- Infer file scopes from diffs and change descriptions
- Leverage AI tools (Aider, Claude) to propose tasks
- Detect dependencies automatically
- Validate against existing bundles

**Current State**:
The planner is a **stub** that returns placeholder bundles. For production use, author workstreams manually in `workstreams/` using the JSON schema.

---

### Archive Utilities (`archive.py`)

Package completed workstreams for analysis and record-keeping.

```python
from pathlib import Path
from core.planning.archive import auto_archive

# Archive a completed worktree
archive_path = auto_archive(
    path=Path(".worktrees/ws-feature-auth"),
    dest_dir=Path("archives/2025-11")
)

# Returns: Path("archives/2025-11/ws-feature-auth.zip")
```

**Archive Contents**:
- Source files from worktree
- Git patches (if available)
- Step execution logs
- Metadata (bundle, results, metrics)

**Use Cases**:
- Post-mortem analysis
- Training data for AI models
- Compliance and audit trails
- Disaster recovery

**Integration with Orchestrator**:

```python
from core.engine.orchestrator import run_workstream
from core.planning.archive import auto_archive
from pathlib import Path

# Execute workstream
result = run_workstream(run_id, ws_id, bundle)

# Archive if successful
if result["success"]:
    wt_path = Path(f".worktrees/{ws_id}")
    archive_path = auto_archive(wt_path, Path("archives/2025-11"))
    print(f"Archived to: {archive_path}")
```

---

### CCPM Integration (`ccpm_integration.py`)

Bridge between CCPM project management and workstream execution.

#### Task to Workstream Conversion

```python
from core.planning.ccpm_integration import task_to_workstream

# Convert CCPM task to workstream bundle
task = {
    "id": "TASK-42",
    "title": "Implement authentication",
    "description": "Add JWT-based authentication to API",
    "estimated_hours": 8,
    "dependencies": ["TASK-10"]
}

bundle = task_to_workstream(
    task=task,
    openspec_id="OS-AUTH-001",
    files_scope=["src/auth.py", "tests/test_auth.py"],
    gate=2
)

# Returns WorkstreamBundle with CCPM metadata
```

#### Epic to Bundle Conversion

```python
from core.planning.ccpm_integration import epic_to_workstream_bundle

# Convert CCPM epic to workstream bundle
epic = {
    "id": "EPIC-5",
    "title": "Authentication System",
    "tasks": [task1, task2, task3],
    "priority": "high"
}

bundle = epic_to_workstream_bundle(
    epic=epic,
    openspec_prefix="OS-AUTH",
    gate=2
)
```

#### Sync Results Back to CCPM

```python
from core.planning.ccpm_integration import sync_workstream_result

# Update CCPM after workstream completion
sync_workstream_result(
    ws_id="ws-feature-auth",
    final_state="completed"  # or "failed"
)
```

#### Parallel Task Validation

```python
from core.planning.ccpm_integration import validate_parallel_tasks

# Check if tasks can run in parallel
conflicts = validate_parallel_tasks(tasks=[task1, task2, task3])

if conflicts:
    print(f"Conflicts detected: {conflicts}")
    # [ConflictError(task_a="TASK-1", task_b="TASK-2", reason="file_overlap")]
```

**Integration with PM Module**:

The CCPM integration works with the `pm/` module for full project management features:

```python
from pm.integrations.ccpm import CCPMClient
from core.planning.ccpm_integration import CCPMIntegration

# Initialize CCPM client
ccpm = CCPMClient(config_path="pm/config/ccpm.yaml")

# Create integration bridge
integration = CCPMIntegration(ccpm_client=ccpm)

# Sync task ‚Üí workstream ‚Üí task lifecycle
integration.sync_bidirectional(run_id="run-2025-11-22-001")
```

---

### Parallelism Detection (`parallelism_detector.py`)

Identifies opportunities for parallel execution.

#### Detect Parallel Opportunities

```python
from core.planning.parallelism_detector import detect_parallel_opportunities
from core.state.bundles import load_and_validate_bundles

# Load bundles
bundles = load_and_validate_bundles("workstreams/examples")

# Detect parallelism
profile = detect_parallel_opportunities(bundles)

# Profile structure:
# {
#     "total_workstreams": 10,
#     "parallelizable": 7,
#     "sequential": 3,
#     "max_parallelism": 4,
#     "estimated_speedup": 2.5,
#     "waves": [
#         ["ws-A", "ws-B", "ws-C", "ws-D"],  # Wave 0
#         ["ws-E", "ws-F"],                  # Wave 1
#         ["ws-G"]                           # Wave 2
#     ],
#     "bottlenecks": ["ws-G"]  # Workstreams blocking others
# }
```

#### Detect Conflict Groups

```python
from core.planning.parallelism_detector import detect_conflict_groups

# Identify workstreams that cannot run in parallel
conflicts = detect_conflict_groups(bundles)

# Returns: {"auth": ["ws-auth-backend", "ws-auth-frontend"]}
# Workstreams in the same conflict group cannot run concurrently
```

**How It Works**:
1. Builds dependency graph from `depends_on` fields
2. Performs topological sort to identify levels
3. Groups independent workstreams at each level
4. Detects file scope overlaps (conflict groups)
5. Estimates speedup based on critical path analysis

**Integration with Scheduler**:

```python
from core.engine.scheduler import build_execution_plan
from core.planning.parallelism_detector import detect_parallel_opportunities

# Detect parallelism
profile = detect_parallel_opportunities(bundles)

# Build execution plan
plan = build_execution_plan(bundles)

print(f"Estimated speedup: {profile['estimated_speedup']:.2f}x")
print(f"Max concurrent: {profile['max_parallelism']}")
print(f"Bottlenecks: {profile['bottlenecks']}")
```

---

## Usage Patterns

### Archive Completed Workstreams

```python
from core.planning.archive import auto_archive
from pathlib import Path
import shutil

# Archive after successful execution
def archive_successful_workstreams(run_id: str):
    from core.state.crud import get_workstreams_for_run
    
    workstreams = get_workstreams_for_run(run_id)
    archive_dir = Path(f"archives/{run_id}")
    
    for ws in workstreams:
        if ws["status"] == "completed":
            wt_path = Path(f".worktrees/{ws['ws_id']}")
            if wt_path.exists():
                archive_path = auto_archive(wt_path, archive_dir)
                print(f"Archived {ws['ws_id']} ‚Üí {archive_path}")
                
                # Optionally clean up worktree
                shutil.rmtree(wt_path)
```

### CCPM Bidirectional Sync

```python
from core.planning.ccpm_integration import CCPMIntegration
from pm.integrations.ccpm import CCPMClient

# Initialize
ccpm_client = CCPMClient()
integration = CCPMIntegration(ccpm_client)

# Pull tasks from CCPM ‚Üí generate workstreams
tasks = ccpm_client.get_tasks_for_sprint("SPRINT-23")
bundles = [
    integration.task_to_workstream(task, gate=2)
    for task in tasks
]

# Execute workstreams
from core.engine.orchestrator import execute_workstreams_parallel
results = execute_workstreams_parallel(run_id, bundles)

# Push results back to CCPM
for ws_id, result in results.items():
    integration.sync_workstream_result(ws_id, result["final_status"])
```

### Parallelism Analysis

```python
from core.planning.parallelism_detector import (
    detect_parallel_opportunities,
    detect_conflict_groups
)

# Load bundles
bundles = load_and_validate_bundles("workstreams/examples")

# Analyze parallelism
profile = detect_parallel_opportunities(bundles)
conflicts = detect_conflict_groups(bundles)

print(f"Total workstreams: {profile['total_workstreams']}")
print(f"Parallelizable: {profile['parallelizable']}")
print(f"Max concurrent: {profile['max_parallelism']}")
print(f"Estimated speedup: {profile['estimated_speedup']:.2f}x")
print(f"\nConflict groups: {conflicts}")
print(f"Bottlenecks: {profile['bottlenecks']}")

# Recommend optimal worker pool size
recommended_workers = min(profile['max_parallelism'], 8)
print(f"\nRecommended workers: {recommended_workers}")
```

---

## Configuration

### Decomposition Rules (`config/decomposition_rules.yaml`)

**Note**: Used by future automated planner (v2.0).

```yaml
# File-based decomposition
file_decomposition:
  enabled: true
  max_files_per_workstream: 5
  group_by_directory: true

# Language-specific rules
language_rules:
  python:
    max_lines_per_workstream: 500
    group_test_with_impl: true
  
  javascript:
    max_lines_per_workstream: 300
    split_frontend_backend: true

# Dependency inference
dependency_detection:
  infer_from_imports: true
  infer_from_git_history: false
```

---

## Testing

Tests are located in `tests/pipeline/`:

```bash
# Archive tests
pytest tests/pipeline/test_archive.py -v

# CCPM integration tests
pytest tests/pipeline/test_ccpm_integration.py -v

# Parallelism detection tests
pytest tests/pipeline/test_parallelism_detector.py -v
```

---

## Roadmap

### Phase 1 (Current - Beta)
- ‚úÖ Archive utilities
- ‚úÖ CCPM integration bridge
- ‚úÖ Parallelism detection
- üöß Automated planner (stub)

### Phase 2 (v2.0 - Planned)
- üîú Full automated planner implementation
- üîú OpenSpec parsing and decomposition
- üîú AI-assisted task inference
- üîú Automatic dependency detection
- üîú Cost-based optimization

### Phase 3 (Future)
- üîú Multi-repository planning
- üîú Cross-project dependency management
- üîú Machine learning for optimal decomposition
- üîú Interactive planning UI

---

## Best Practices

1. **Archive completed workstreams** - Enables post-mortem analysis
2. **Use CCPM integration for project tracking** - Bidirectional sync keeps PM tools updated
3. **Analyze parallelism before execution** - Optimize worker pool size
4. **Respect conflict groups** - Prevents concurrent modifications to same files
5. **Review auto-generated plans** - Always validate automated planning outputs (when available)
6. **Start with manual planning** - Author bundles manually until v2.0 planner is ready

---

## Migration from Legacy

Legacy import paths are deprecated:

```python
# ‚ùå DEPRECATED
from src.pipeline.planner import plan_workstreams_from_spec

# ‚úÖ USE INSTEAD
from core.planning.planner import plan_workstreams_from_spec
```

---

## Related Documentation

- **Workstream Bundles**: `workstreams/README.md` - Manual authoring guide
- **State Management**: `core/state/README.md` - Bundle loading and validation
- **Orchestration**: `core/engine/README.md` - Execution and scheduling
- **CCPM Integration**: `pm/README.md` - Project management features
- **Parent Module**: `core/README.md` - Core pipeline overview
- **OpenSpec**: `specifications/README.md` - Specification management
