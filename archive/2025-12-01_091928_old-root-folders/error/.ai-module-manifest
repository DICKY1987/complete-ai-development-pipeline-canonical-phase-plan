# .ai-module-manifest
# AI-readable module specification for error

module: "error"
purpose: "Error detection system: plugin-based code analysis, issue tracking"
layer: "domain"  # Domain layer - core business logic

# Submodules
submodules:
  - name: "error.engine"
    purpose: "Error detection engine, plugin orchestration"
    manifest: "error/engine/.ai-module-manifest"
    
  - name: "error.plugins"
    purpose: "Detection plugins (Python, imports, etc.)"
    note: "Plugin architecture - auto-discovered from plugins/ directory"

# Entry points
entry_points:
  - file: "engine/error_engine.py"
    class: "ErrorEngine"
    function: "scan(path: str)"
    description: "Scan codebase for errors using all enabled plugins"
    
  - command: "python -m error.engine --scan <path>"
    description: "CLI entry point for error detection"
    
  - file: "plugins/python_ruff/plugin.py"
    function: "parse(file_path: str)"
    description: "Example plugin - Python linting via Ruff"

# Key patterns
key_patterns:
  - "Plugins auto-discovered from error/plugins/ directory"
  - "Each plugin implements parse() method returning List[Error]"
  - "Error engine aggregates results from all plugins"
  - "Plugins can optionally implement fix() for auto-repair"
  - "Errors logged to database via core.state.crud"
  - "Plugin configuration via error_engine_config.yaml"

# Common tasks
common_tasks:
  - task: "Scan code for errors"
    command: "python -m error.engine --scan path/to/code"
    code: |
      from error.engine.error_engine import ErrorEngine
      engine = ErrorEngine()
      errors = engine.scan("path/to/code")
      
  - task: "Generate error report"
    command: "python -m error.engine --scan . --format=json > errors.json"
    code: |
      engine = ErrorEngine()
      errors = engine.scan(".")
      report = engine.report(format="json")
      
  - task: "Add new detection plugin"
    steps:
      - "Create plugin directory: error/plugins/my_plugin/"
      - "Create plugin.py with parse() method"
      - "Return List[Error] from parse()"
      - "Add tests in tests/error/plugins/test_my_plugin.py"
      - "Plugin auto-discovered on next engine run"
      
  - task: "Filter errors by type"
    code: |
      errors = engine.scan(".")
      python_errors = [e for e in errors if e.language == "python"]
      import_errors = [e for e in errors if e.type == "import"]

# Plugin interface
plugin_interface:
  required_methods:
    - name: "parse(file_path: str) -> List[Error]"
      description: "Detect errors in file"
      
  optional_methods:
    - name: "fix(file_path: str, error: Error) -> bool"
      description: "Auto-repair detected error"
      
    - name: "configure(config: Dict) -> None"
      description: "Load plugin configuration"
      
  error_structure:
    fields:
      - "file: str - Path to file with error"
      - "line: int - Line number"
      - "column: int - Column number"
      - "type: str - Error type (e.g., 'import', 'syntax')"
      - "message: str - Human-readable message"
      - "severity: str - 'error' | 'warning' | 'info'"
      - "language: str - Programming language"
      
  example: |
    class MyPlugin:
        def parse(self, file_path: str) -> List[Error]:
            errors = []
            # Analyze file
            if issue_found:
                errors.append(Error(
                    file=file_path,
                    line=42,
                    type="my_issue",
                    message="Issue description",
                    severity="error",
                    language="python"
                ))
            return errors

# Available plugins
available_plugins:
  - name: "python_ruff"
    description: "Python linting via Ruff"
    languages: ["python"]
    status: "stable"
    
  - name: "import_validator"
    description: "Validates import paths against CI standards"
    languages: ["python"]
    status: "stable"
    checks: ["deprecated imports", "section-based paths"]

# Gotchas
gotchas:
  - "Plugins must return List[Error], not raise exceptions"
  - "Plugin discovery happens at engine initialization"
  - "Plugin order is non-deterministic (use dict, not list)"
  - "Large codebases can be slow (plugins run sequentially)"
  - "Error.file path should be absolute or relative to scan root"
  - "Plugins share no state (each runs independently)"

# Deprecated
deprecated:
  - old: "MOD_ERROR_PIPELINE.*"
    new: "error.*"
    reason: "Section-based refactor (2025-11-20)"
    
  - old: "MOD_ERROR_PIPELINE.error_engine"
    new: "error.engine.error_engine"
    reason: "Section-based refactor (2025-11-20)"

# Dependencies
dependencies:
  external:
    - pathlib
    - typing
    - json
    - subprocess  # For calling external linters
    
  internal:
    - core.state.crud  # For logging errors to database
    
  plugin_specific:
    python_ruff:
      - ruff  # Python linter
    import_validator:
      - ast   # Python AST parsing

# Test files
test_files:
  - "tests/error/engine/test_error_engine.py"
  - "tests/error/plugins/test_python_ruff.py"
  - "tests/error/plugins/test_import_validator.py"

# Documentation
documentation:
  - "error/README.md"
  - "docs/ARCHITECTURE.md (Error Detection section)"
  - "docs/plugin-ecosystem-summary.md"

# Status
status:
  maturity: "beta"  # ~70% complete
  test_coverage: "~65%"
  production_ready: false  # Phase G in progress
  last_major_change: "2025-11-20 (section-based refactor)"

# AI quick reference
ai_quick_reference:
  scan_code: "python -m error.engine --scan ."
  from_code: "from error.engine.error_engine import ErrorEngine; errors = ErrorEngine().scan('.')"
  filter: "python_errors = [e for e in errors if e.language == 'python']"
  report: "engine.report(format='json')"

# Output formats
output_formats:
  json:
    description: "Machine-readable JSON"
    use: "CI/CD pipelines, automated processing"
    
  text:
    description: "Human-readable text"
    use: "Terminal output, quick review"
    
  github:
    description: "GitHub Actions annotations"
    use: "GitHub PR checks"

# Performance
performance:
  - "O(n) where n = number of files"
  - "Plugins run sequentially (no parallelism yet)"
  - "Bottleneck: External process calls (e.g., ruff)"
  - "Caching: None (re-scans all files each run)"

# Roadmap
roadmap:
  phase_g2:
    - "Complete AI agent integration"
    - "Add auto-fix for common errors"
    
  phase_g3:
    - "Plugin parallelization"
    - "Incremental scanning (only changed files)"
    
  future:
    - "More language plugins (JavaScript, TypeScript)"
    - "Custom rule configuration"
    - "Error trend analysis"

# Recent changes
recent_changes:
  - date: "2025-11-20"
    change: "Refactored from MOD_ERROR_PIPELINE to error"
    impact: "Import paths changed"
    
  - date: "2025-11-19"
    change: "Added import_validator plugin"
    impact: "CI now validates import paths"
    
  - date: "2025-11-18"
    change: "Improved error reporting formats"
    impact: "Added GitHub Actions format"

# Related modules
related_modules:
  - module: "core"
    relationship: "Errors logged to core.state database"
    
  - module: "specifications"
    relationship: "Error detection can run as workstream step"

# For AI tools
for_ai_tools:
  suggesting_error_detection: |
    When user mentions linting, validation, or code quality:
    1. Suggest: python -m error.engine --scan <path>
    2. Explain: Runs all enabled detection plugins
    3. Point to: error/README.md for plugin details
    
  common_questions:
    - q: "How do I lint Python code?"
      a: "python -m error.engine --scan . (uses Ruff plugin)"
      
    - q: "How do I check for deprecated imports?"
      a: "python -m error.engine --scan . (import_validator plugin)"
      
    - q: "How do I add custom checks?"
      a: "Create plugin in error/plugins/ with parse() method"
