## Optimal Solutions for Autonomous Headless Systems

Your documents reveal a **Card → Ledger → Registry** pattern that's ideal for AI-driven headless automation. Here's how to merge capability catalogs with your existing systems:

---

## 1) **ULID-Based Capability IDs** (Proven Pattern)

Your systems already use ULID for deterministic identity. Apply this to capabilities:

```yaml
# capabilities/cards/01JC4GHPR_CREATE.yaml
ulid: 01JC4GHPR82XYZABC...          # immutable ID
key: cap.gh.pr.create.v1           # human-readable alias
semver: 1.0.0                      # capability version
status: active
path: snippets/gh/pr_create.ps1
intents:
  - pattern: "(create|open).*(pr|pull request)"
    confidence: 0.92
prerequisites:
  - check: "gh auth status"
    verify_script: verify/gh_auth_status.ps1
command_template: "gh pr create --base {base} --fill"
toolchain:
  - gh >= 2.0
platforms: [windows, macos, linux]
card_version: 1                     # metadata revisions
```

**Benefits:**
- Immutable ULID survives renames
- Semver tracks capability evolution
- Cards are version-controlled and auditable

---

## 2) **Append-Only Capability Ledger** (Your Pattern)

Track every capability resolution/execution:

```jsonl
{"event_ulid":"01JC4EVT001...","ts":"2025-11-11T14:22:00Z","type":"RESOLVE","subject_ulid":"01JC4GHPR...","payload":{"user_intent":"create PR","matched_by":"regex","confidence":0.92},"actor":{"by":"headless-agent","via":"aider-cli"}}
{"event_ulid":"01JC4EVT002...","ts":"2025-11-11T14:22:01Z","type":"VERIFY","subject_ulid":"01JC4GHPR...","payload":{"prereq":"gh_auth","result":"pass","duration_ms":45},"actor":{"by":"headless-agent","via":"capcatalog@0.2.0"}}
{"event_ulid":"01JC4EVT003...","ts":"2025-11-11T14:22:02Z","type":"EXECUTE","subject_ulid":"01JC4GHPR...","payload":{"params":{"base":"main"},"exit_code":0,"duration_ms":1234},"actor":{"by":"headless-agent","via":"capcatalog@0.2.0"}}
```

**Queries enabled:**
- "What capabilities did run X use?"
- "How often does `cap.gh.pr.create` fail verification?"
- "Which intents have no matching capability?" (catalog gap analysis)

---

## 3) **Capability Registry** (Generated, Fast Lookup)

```yaml
# registry/capabilities.registry.yaml
by_ulid:
  01JC4GHPR...:
    key: cap.gh.pr.create.v1
    semver: 1.0.0
    status: active
    intents: ["create pr", "open pull request"]
    prereqs_count: 2
    last_used: "2025-11-11T14:22:00Z"
    usage_count: 127
    success_rate: 0.96

by_key:
  cap.gh.pr.create.v1: 01JC4GHPR...

by_intent:
  "create pr": [01JC4GHPR..., 01JC4ISSUE...]
  "open pull request": [01JC4GHPR...]

by_tool:
  gh: [01JC4GHPR..., 01JC4ISSUE..., 01JC4WORKFLOW...]
```

**Regenerated by CI** after capability card changes, similar to your doc registry pattern.

---

## 4) **Headless Agent Integration** (JSON Contract)

Agents call capability resolver via **stdin/stdout JSON contract** (no HTTP server needed):

```bash
# Input JSON
echo '{"intent":"create a PR to main","context":{"repo":true,"auth":true}}' | \
  pwsh Resolve-Capability.ps1

# Output JSON
{
  "capability_ulid": "01JC4GHPR...",
  "capability_key": "cap.gh.pr.create.v1",
  "confidence": 0.92,
  "verified": true,
  "command": "gh pr create --base main --fill",
  "prerequisites": [
    {"check": "gh auth status", "result": "pass"}
  ],
  "audit_event_ulid": "01JC4EVT001..."
}
```

**Deterministic, scriptable, no server overhead.**

---

## 5) **Plugin Manifest for Capability Cards**

Apply your plugin manifest pattern to capability management:

```yaml
# capabilities/manifests/PLG_CAP_RESOLVER.yaml
apiVersion: capability.contract.v1
key: PLG_CAP_RESOLVER
version: 0.2.0
contract: ">=1.0 <2.0"
capabilities: ["resolve", "verify", "execute"]
config_schema: "schemas/resolver.config.schema.json"
inputs:
  - name: user_intent
    schema: "schemas/resolve.in.schema.json"
outputs:
  - name: resolution
    schema: "schemas/resolve.out.schema.json"
conformance:
  tests:
    - "tests/behavior/resolution.feature"
```

**Contracts enforce:** Input/output schemas, versioning, testability.

---

## 6) **Efficient Storage for Headless Systems**

### **Recommendation: JSONL + SQLite Hybrid**

```
capabilities/
├─ cards/                         # Source of truth (git-versioned)
│  ├─ 01JC4GHPR_GH_PR_CREATE.yaml
│  ├─ 01JC4ISSUE_GH_ISSUE_CREATE.yaml
│  └─ ...
├─ registry/
│  ├─ capabilities.db             # SQLite FTS5 for instant search
│  └─ capabilities.registry.yaml  # Human-readable index
├─ .ledger/
│  └─ capabilities.jsonl          # Append-only usage log
└─ verify/                        # Prereq check scripts
   ├─ gh_auth_status.ps1
   └─ command_on_path.ps1
```

### **SQLite FTS5 Schema**

```sql
CREATE TABLE capability_cards (
  ulid TEXT PRIMARY KEY,
  key TEXT UNIQUE NOT NULL,
  semver TEXT,
  status TEXT,
  card_yaml BLOB,
  updated_at TEXT
);

CREATE VIRTUAL TABLE capability_search USING fts5(
  key, intents, commands, prerequisites, 
  content='capability_cards',
  content_rowid='rowid'
);

-- Search: <1ms for 10K capabilities
SELECT ulid FROM capability_search 
WHERE intents MATCH 'create AND (pr OR pull request)' 
LIMIT 5;
```

**Benefits:**
- **Cards (YAML)**: Human-editable, git-versioned
- **SQLite**: Sub-millisecond search for headless agents
- **Ledger (JSONL)**: Audit trail, grep-able, append-only
- **Registry (YAML)**: Human overview, CI-generated

---

## 7) **Headless CI Gates** (L0-L5 Pattern)

Apply your validation pipeline levels:

```yaml
# .github/workflows/capability-guard.yml
- name: L0 Static
  run: |
    # Validate all capability cards against schema
    python scripts/validate_capability_cards.py

- name: L1 Contract
  run: |
    # Verify all verify/ scripts are executable
    python scripts/test_verify_scripts.py

- name: L2 Behavior
  run: |
    # BDD: Given intent X, capability Y is resolved
    pytest tests/behavior/capability_resolution.feature

- name: L3 Integration
  run: |
    # Full resolver with real tools (gh, docker, etc.)
    python scripts/test_resolver_integration.py

- name: Auto-Publish
  if: success()
  run: |
    # Rebuild registry, update SQLite, commit ledger event
    python scripts/rebuild_capability_registry.py
```

---

## 8) **Autonomous Agent Wrapper**

```python
# autonomous_agent.py (headless CLI app)
import json, subprocess, ulid
from pathlib import Path

def resolve_capability(user_intent: str, context: dict) -> dict:
    """Query capability catalog via subprocess"""
    input_json = json.dumps({"intent": user_intent, "context": context})
    
    result = subprocess.run(
        ["pwsh", "Resolve-Capability.ps1"],
        input=input_json,
        capture_output=True,
        text=True,
        check=True
    )
    
    resolution = json.loads(result.stdout)
    
    # Log to ledger
    ledger_event = {
        "event_ulid": str(ulid.new()),
        "ts": datetime.utcnow().isoformat() + "Z",
        "type": "RESOLVE",
        "subject_ulid": resolution["capability_ulid"],
        "payload": {"intent": user_intent, "confidence": resolution["confidence"]},
        "actor": {"by": "headless-agent", "via": f"aider-cli@{VERSION}"}
    }
    
    Path(".ledger/capabilities.jsonl").open("a").write(json.dumps(ledger_event) + "\n")
    
    return resolution

# Usage in headless workflow
resolution = resolve_capability("create GitHub PR", {"repo": True, "auth": True})
if resolution["verified"]:
    subprocess.run(resolution["command"], shell=True)
```

---

## 9) **Key Differences from Web-UI Systems**

| Pattern | Web UI Approach | Headless Approach |
|---------|----------------|-------------------|
| Discovery | HTTP `/resolve` endpoint | JSON stdin/stdout contract |
| Storage | Single server DB | Distributed YAML cards + SQLite cache |
| Audit | Real-time metrics | Append-only JSONL ledger |
| Verification | Async with caching | Inline with deterministic results |
| Updates | Hot reload | CI rebuild + artifact publish |

---

## 10) **Recommended Stack for Your Systems**

**Phase 1: Capability Cards (1 day)**
```
capabilities/cards/
├─ 01JC4GH_*.yaml      # 20-30 high-frequency capabilities
└─ manifests/          # Plugin manifests
```

**Phase 2: SQLite Resolver (1 day)**
```python
# scripts/resolve_capability.py
# Queries SQLite FTS5 → loads YAML card → runs verify/ → returns JSON
```

**Phase 3: Ledger Integration (2 hours)**
```
.ledger/capabilities.jsonl  # Track every RESOLVE/VERIFY/EXECUTE
```

**Phase 4: CI Gates (2 hours)**
```yaml
# .github/workflows/capability-guard.yml
# Schema validation → conformance tests → auto-publish
```

---

## Bottom Line

Your **Card → Ledger → Registry** pattern is **perfect for autonomous capability management**. The JSONL ledger provides audit trails, ULID ensures stability, and SQLite enables <1ms lookups for headless agents—all without server overhead.

Want me to generate the starter repo structure with capability cards for gh/PowerShell/Docker, SQLite schema, and PowerShell resolver script?

# 2) Compositions (multi-step recipes)

**What:** A “meta-card” that chains capabilities in order.

```yaml
# capabilities/cards/01JC4COMP_PR_FROM_BRANCH.yaml
ulid: 01JC4COMPPRFROMBRNCH
key: comp.git.branch→push→pr.v1
kind: composition
summary: Create branch, push it, then open a PR to base.
steps:
  - use: cap.git.branch.create.v1
    with: { name: "{branch}" }
  - use: cap.git.push.current.v1
  - use: cap.gh.pr.create.v1
    with: { base: "{base}" }
params_schema:
  type: object
  required: [branch, base]
```

**How it runs:** resolver picks `comp.git.branch→push→pr.v1` → executes each step in order (and each step still runs its own Verify).

---

# 7) SQLite FTS index (instant lookups)

**What:** Cards remain YAML in git; a tiny SQLite db accelerates search.

```sql
-- registry/capabilities.sql (loaded into capabilities.db)
CREATE TABLE cards (
  rowid INTEGER PRIMARY KEY,
  ulid TEXT UNIQUE,
  key  TEXT UNIQUE,
  yaml TEXT,
  updated_at TEXT
);

CREATE VIRTUAL TABLE idx USING fts5(
  key, intents, commands, summary, tokenize='unicode61'
);

-- Sync helpers (example for insert/update)
-- Insert card and index text extracted from YAML:
-- INSERT INTO cards(ulid,key,yaml,updated_at) VALUES(?,?,?,?);
-- INSERT INTO idx(rowid,key,intents,commands,summary) VALUES(last_insert_rowid(),?,?,?,?);

-- Query (sub-ms on thousands of cards):
-- Find PR creation:
SELECT ulid,key
FROM idx
WHERE idx MATCH 'create AND (pr OR "pull request")'
LIMIT 3;
```

**How it’s used:** your resolver loads `capabilities.db`, runs the FTS query, then pulls the matching YAML card(s) for Verify/execute.

---

# 8) Ledger enrichment (better forensics)

**What:** Every resolve/verify/execute is logged with run/session IDs and environment info.

```json
// .ledger/capabilities.jsonl  (append-only)
{"event_ulid":"01JC4RUN0001","ts":"2025-11-11T12:40:01Z","type":"RESOLVE",
 "correlation_id":"01JC4SESSIONABC","subject_ulid":"01JC4COMPPRFROMBRNCH",
 "ask":"open a PR to main from feature/x","candidate_keys":["comp.git.branch→push→pr.v1"],
 "env":{"os":"Windows 11","pwsh":"7.4.5","gh":"2.61.0"}}

{"event_ulid":"01JC4RUN0002","ts":"2025-11-11T12:40:02Z","type":"VERIFY",
 "correlation_id":"01JC4SESSIONABC","subject_ulid":"01JC4GHPRCREATE",
 "tier":"L1","prereq":"gh_auth","result":"pass","duration_ms":41}

{"event_ulid":"01JC4RUN0003","ts":"2025-11-11T12:40:03Z","type":"EXECUTE",
 "correlation_id":"01JC4SESSIONABC","subject_ulid":"01JC4GHPRCREATE",
 "command":"gh pr create --base main --fill",
 "params":{"base":"main"},"exit_code":0,"duration_ms":1230}
```

**Failure taxonomy example:**

```json
{"type":"VERIFY","result":"fail","failure_class":"AUTH_MISSING","hint":"Run `gh auth login`"}
```

---

## Mini “how it works” flow

1. **Search:** resolver queries SQLite FTS → gets `comp.git.branch→push→pr.v1`.
2. **Verify & Run:** executes each step’s Verify → Command.
3. **Log:** writes enriched JSONL entries with `correlation_id` and env details.

That’s it—compositions for multi-step tasks, instant search via SQLite, and an audit-ready ledger with useful context.
