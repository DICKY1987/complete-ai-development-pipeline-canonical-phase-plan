wrap every gh … operation in a deterministic envelope so that either (a) it succeeds exactly as intended, or (b) it aborts with a precise reason—never a silent half-state.
Hydrate args = take a command template with placeholders and fill them with concrete values (from user input, defaults, or context), producing an exact argument list.

Call it deterministically = build the same exact argv every time for the same inputs and context—no randomness, no hidden env leaks, no shell quirks.

Idempotent mutations: prefer “upsert” semantics where possible (e.g., edit PR if it exists with the same head instead of always creating).

Compare-and-swap: for any change, assert current state == expected before mutating (simulate CAS with a pre-GET + conditional logic).

Concurrency control: create a repo-scoped lock file (e.g., .locks/<capability>.lock stored via git-notes or an S3/Drive backend) so two agents don’t race the same resource.

Strict inputs: cards define placeholders with required/type/one_of and canonicalization (trim, case rules).

Strict environment: Taskfile/Invoke runners set env: explicitly; scrub the rest.

Time: always use UTC; if you embed dates, pass them in as hydrated args rather than calling now() inside the command.

Read-after-write verification: never assume; always re-query GitHub to certify.

Reconciliation tasks: provide “doctor” capabilities that detect and repair drift (e.g., PR exists but wrong title/labels).